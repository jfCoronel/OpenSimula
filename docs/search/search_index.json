{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This site contains the documentation for the OpenSimula project. Github site OpenSimula is a component-based time simulation environment in Python. The main objective is the thermal and energy simulation of different systems and installations, mainly in buildings, although it can be used to simulate any component that presents a temporal variation. Structure The general object structure provided by OpenSimula is composed of three main elements: Simulation: The global environment for simulation. Project: A set of components that define a problem that can be temporarily simulated. Component: These are the base elements on which the simulation is performed. The types of components currently available can be consulted in section Component list . Parameters Parameters are used to define the characteristics that make up the projects and components. Parameters can be of different types depending on the type of information they contain (strings, boolean, integer, float, options, ...). A list of all parameter types and their possibilities can be found in the User guide . : Variables Variables are elements included in the components to store the temporal information generated during the simulation. Documentation Getting started User guide Component list Developer guide Release notes This is the list of changes to OpenSimula between each release. For full details, see the commit logs. Current Version 0.3.2 0.4.1 (March 13, 2025): Stable versions of HVAC_DX_system and HVAC_DX_equipment. Passed all cases of section 9. \u201cSpace-cooling equipment performance tests\u201d of ASHRAE 140-2023. 0.3.2 (February 20, 2025): Debugging HVAC_DX_system and HVAC_DX_equipment. Passed cases CE100 to CE340 of section 9. \u201cSpace-cooling equipment performance tests\u201d of ASHRAE 140-2023. 0.3.1 (January 24, 2025): Implementation HVAC_DX_system and HVAC_DX_equipment 0.2.0 (January 1, 2025): First implementation for the building definition components and the HVAC_perfect_system \u00a9 JFC 2025","title":"Home"},{"location":"#structure","text":"The general object structure provided by OpenSimula is composed of three main elements: Simulation: The global environment for simulation. Project: A set of components that define a problem that can be temporarily simulated. Component: These are the base elements on which the simulation is performed. The types of components currently available can be consulted in section Component list .","title":"Structure"},{"location":"#parameters","text":"Parameters are used to define the characteristics that make up the projects and components. Parameters can be of different types depending on the type of information they contain (strings, boolean, integer, float, options, ...). A list of all parameter types and their possibilities can be found in the User guide . :","title":"Parameters"},{"location":"#variables","text":"Variables are elements included in the components to store the temporal information generated during the simulation.","title":"Variables"},{"location":"#documentation","text":"Getting started User guide Component list Developer guide","title":"Documentation"},{"location":"#release-notes","text":"This is the list of changes to OpenSimula between each release. For full details, see the commit logs. Current Version 0.3.2 0.4.1 (March 13, 2025): Stable versions of HVAC_DX_system and HVAC_DX_equipment. Passed all cases of section 9. \u201cSpace-cooling equipment performance tests\u201d of ASHRAE 140-2023. 0.3.2 (February 20, 2025): Debugging HVAC_DX_system and HVAC_DX_equipment. Passed cases CE100 to CE340 of section 9. \u201cSpace-cooling equipment performance tests\u201d of ASHRAE 140-2023. 0.3.1 (January 24, 2025): Implementation HVAC_DX_system and HVAC_DX_equipment 0.2.0 (January 1, 2025): First implementation for the building definition components and the HVAC_perfect_system \u00a9 JFC 2025","title":"Release notes"},{"location":"component_list/","text":"Component List Common parameters All the components include these three parameters: name [ string ]: Name of the component. type [ string ]: Type of the component. description [ string ]: Description of the component. We have divided the list of all components into several groups of related components: Components to define shedules : Day_schedule, Week_schedule, Year_schedule. Components for reading files : File_met, File_data. Constructive components : Material, Construction, Glazing, Frame, Opening_type. Building definition components : Building, Space_type, Space, Exterior_surface, Interior_surface, Underground_surface, Virtual_surface, Opening, Shadow_surface. HVAC systems components : HVAC_perfect_system. Components for various utilities : Calculator.","title":"Component list"},{"location":"component_list/#component-list","text":"","title":"Component List"},{"location":"component_list/#common-parameters","text":"All the components include these three parameters: name [ string ]: Name of the component. type [ string ]: Type of the component. description [ string ]: Description of the component. We have divided the list of all components into several groups of related components: Components to define shedules : Day_schedule, Week_schedule, Year_schedule. Components for reading files : File_met, File_data. Constructive components : Material, Construction, Glazing, Frame, Opening_type. Building definition components : Building, Space_type, Space, Exterior_surface, Interior_surface, Underground_surface, Virtual_surface, Opening, Shadow_surface. HVAC systems components : HVAC_perfect_system. Components for various utilities : Calculator.","title":"Common parameters"},{"location":"component_list_HVAC_systems/","text":"Component List for HVAC system definition HVAC_perfect_system Component for the perfect conditioning of a space. With this component we can obtain the heating and cooling loads (sensible and latent). Parameters file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be controlled by this system. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. outdoor_air_flow [ math_exp , unit = \"m\u00b3/s\", default = \"0\"]: Outside air flow rate (ventilation) supplied to the space. This flow rate is only entered if the system is in operation. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. humidifying_setpoint [ math_exp , unit = \"%\", default = \"0\"]: Space relative humidity setpoint for humidification. If the relative humidity of the space is below this value, latent heat is added to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. dehumidifying_setpoint [ math_exp , unit = \"%\", default = \"100\"]: Space relative humidity setpoint for dehumidification. If the relative humidity of the space is higher this value, latent heat is removed to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. If outside air (ventilation) is present, it is introduced into the space as \u2018uncontrolled system heat\u2019, and the load values associated with the ventilation can be viewed in the space. The load supplied by the system is that required to maintain the space within the specified temperature and humidity set points, including ventilation if present. Example: ... system = osm.components.HVAC_perfect_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"outdoor_air_flow\": \"0.1\", \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"humidifying_setpoint\": \"30\", \"dehumidifying_setpoint\": \"70\", \"input_variables\":[\"f = HVAC_schedule.values\"], \"system_on_off\": \"f\" } system.set_parameters(param) Variables After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system, positive for heating and negative for cooling. Q_latent [W]: Latent heat supplied by the system, positive for humidification, negative for dehumidification. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. humififying_setpoint [%]: Low relative humidity setpoint. dehumidifying_setpoint [%]: High relative humidity setpoint. state [flag]: Operation of the system: off (0), heating (1), colling (-1), venting (3). HVAC_DX_equipment Component to define a direct expansion air conditioning equipment. It can be used to define compact or split 1x1 units. This equipment can be used for one or more HVAC systems. Parameters nominal_air_flow [ float , unit = \"m\u00b3/s\", default = 1, min = 0]: Nominal supply air flow. nominal_total_cooling_capacity [ float , unit = \"W\", default = 0, min = 0]: Total cooling gross capacity at nominal cooling conditions. nominal_sensible_cooling_capacity [ float , unit = \"W\", default = 0, min = 0]: Sensible cooling gross capacity at nominal cooling conditions. nominal_cooling_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the equipment at nominal cooling conditions. It must include all the consumptions: compressor, external fan, etc. except the power specified in \u201cindoor_fan_power\u201d. indoor_fan_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the indoor fan, this power will be added as heat to the air stream. nominal_cooling_conditions [ float-list , unit = \"\u00baC\", default = [27, 19, 35]]: Nominal cooling conditions, in order: indoor dry bulb temperature, indoor wet bulb temperature, outdoor dry bulb temperature. total_cooling_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the total cooling capacity of the equipment in conditions different from the nominal ones. sensible_cooling_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the sensible cooling capacity of the equipment in conditions different from the nominal ones. cooling_power_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the electric power consumption at cooling full load operation of the equipment in conditions different from the nominal ones. EER_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the EER, defined as cooling total load supplied by de equipment divided by de electric power consumption, of the equipment in conditions different from the nominal ones. This expression should reflect the partial load behavior of the equipment. nominal_heating_capacity [ float , unit = \"W\", default = 0, min = 0]: Heating capacity at nominal heating conditions. nominal_heating_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the equipment at nominal heating conditions. It must include all the consumptions: compressor, external fan, etc, except the power specified in \u201cno_load_power\u201d. nominal_heating_conditions [ float-list , unit = \"\u00baC\", default = [20, 7, 6]]: Nominal heating conditions, in order: indoor dry bulb temperature, outdoor dry bulb temperature, outdoor wet bulb temperature. heating_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the heating capacity of the equipment in conditions different from the nominal ones. heating_power_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the electric power consumption at heating full load operation of the equipment in conditions different from the nominal ones. COP_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the COP, defined as heating load supplied by de equipment divided by de electric power consumption, of the equipment in conditions different from the nominal ones. This expression should reflect the partial load behavior of the equipment. indoor_fan_operation [ option , default = \"CONTINUOUS\", options = [\"CONTINUOUS\",\"CYCLING\"]]: If the value is \u201cCONTINUOUS\u201d the fan will always run, consuming electrical energy and adding heat to the air stream, even when there is no load. If we specify \u201cCYCLING\u201d the fan will run a fraction of time equal to the partial load at which the equipment operates, therefore, when there is no load there will be no consumption of the fan. dry_coil_model [ option , default = \"SENSIBLE\", options = [\"SENSIBLE\",\"TOTAL\",\"INTERPOLATION\"]]: When calculating the total and sensible capacity of the equipment under non-nominal conditions, it is possible that the total capacity is lower than the sensible capacity. In such a case it will be assumed that the coil does not dehumidify and that the total capacity is equal to the sensible capacity. We will use for both values the value of the sensible if the chosen option is \u201cSENSIBLE\u201d and the total if the chosen option is \u201cTOTAL\u201d. power_dry_coil_correction [ boolean , default = True]: When the total and sensible power are equal, dry coil, the power expression may be incorrect. If this parameter is activated the simulation will look for the wet bulb temperature that makes the total and sensible capacities equal and use that temperature in the expression that corrects the cooling power. expression_max_values [ float-list , unit = \"-\", default = [60,30,60,30,1.5,1]]: Maximum values allowed in the mathematical expressions. The order is [ T_idb [\u00baC] , T_iwb [\u00baC] , T_odb [\u00baC], T_owb [\u00baC], F_air [frac], F_load [frac] ]. If any variable exceeds these values, the maximum value is taken. expression_min_values [ float-list , unit = \"-\", default = [0,0,-30,-30,0,0]]: Minimum values allowed in the mathematical expressions. The order is [ T_idb [\u00baC] , T_iwb [\u00baC] , T_odb [\u00baC], T_owb [\u00baC], F_air [frac], F_load [frac] ]. If any variable is lower than these values, the minimum value is taken. All mathematical expressions can include the following independent variables. T_idb [\u00baC]: Indoor dry bulb temperature, at the coil inlet of the indoor unit. T_iwb [\u00baC]: Indoor wet bulb temperature, at the coil inlet of the indoor unit. T_odb [\u00baC]: Outdoor dry bulb temperature. T_owb [\u00baC]: Outdoor wet bulb temperature. F_air [frac]: Actual supply air flow divided by nominal supply air flow. \"EER_expression\" and \"COP_expression\" may also include the variable F_load , which represents the partial load state of the equipment, calculated as the thermal power supplied at a given instant divided by the cooling or heating capacity at the current operation conditions. Example: ... equipment = osm.components.HVAC_DX_equipment(\"equipment\",project) param = { \"nominal_air_flow\": 0.417, \"nominal_total_cooling_capacity\": 6000, \"nominal_sensible_cooling_capacity\": 4800, \"nominal_cooling_power\": 2400, \"indoor_fan_power\": 240, \"indoor_fan_operation\": \"CONTINUOUS\", \"total_cooling_capacity_expression\": \"0.88078 + 0.014248 * T_iwb + 0.00055436 * T_iwb**2 - 0.0075581 * T_odb + 3.2983E-05 * T_odb**2 - 0.00019171 * T_odb * T_iwb\", \"sensible_cooling_capacity_expression\": \"0.50060 - 0.046438 * T_iwb - 0.00032472 * T_iwb**2 - 0.013202 * T_odb + 7.9307E-05 * T_odb**2 + 0.069958 * T_idb - 3.4276E-05 * T_idb**2\", \"cooling_power_expression\": \"0.11178 + 0.028493 * T_iwb - 0.00041116 * T_iwb**2 + 0.021414 * T_odb + 0.00016113 * T_odb**2 - 0.00067910 * T_odb * T_iwb\", \"EER_expression\": \"0.20123 - 0.031218 * F_load + 1.9505 * F_load**2 - 1.1205 * F_load**3\", \"nominal_heating_capacity\": 6500, \"nominal_heating_power\": 2825, \"heating_capacity_expression\": \"0.81474 + 0.030682602 * T_owb + 3.2303E-05 * T_owb**2\", \"heating_power_expression\": \"1.2012 - 0.040063 * T_owb + 0.0010877 * T_owb**2\", \"COP_expression\": \"0.085652 + 0.93881 * F_load - 0.18344 * F_load**2 + 0.15897 * F_load**3\" } equipment.set_parameters(param) HVAC_DX_system Component for the simulation of an air-conditioning system for a space and using equipment in direct expansion \"HVAC_DX_equipment\". Parameters file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be air-conditioned by this system. equipment [ component , default = \"not_defined\", component type = HVAC_DX_equipment]: Reference to the \"HVAC_DX_equipment\" component used by this system. supply_air_flow [ float , unit = \"m\u00b3/s\", default = 1, min = 0]: Supply air flow used for all the simulation. outdoor_air_flow [ float , unit = \"m\u00b3/s\", default = 0, min = 0]: Outdoor air flow used for all the simulation. The outside air is mixed with the return air from the room before it enters the indoor coil. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. control_type [ option , default = \"PERFECT\", options = [\"PERFECT\",\"TEMPERATURE\"]]: Type of control used, for the case \u2018PERFECT\u2019 the system will maintain exactly the desired temperature in the space, provided it has sufficient capacity. For the \u2018TEMPERATURE\u2019 case the power supplied by the system is calculated through a linear regulation law with the room temperature using the thermostat bandwidths, see figure below. cooling_bandwidth [ float , unit = \"\u00baC\", default = 1, min = 0]: Bandwidth used in case control_type is set to \"TEMPERATURE\" for the cooling setpoint. heating_bandwidth [ float , unit = \"\u00baC\", default = 1, min = 0]: Bandwidth used in case control_type is set to \"TEMPERATURE\" for the heating setpoint. economizer [ option , default = \"NO\", options = [\"NO\",\"TEMPERATURE\",\"TEMPERATURE_NOT_INTEGRATED\",\"ENTHALPY\",\"ENTHALPY_LIMITED\"]]: Free cooling using outside air (economizer). If the option selected is \u201cNO\u201d no economizer will be used, for the other options the economizer will be used with different control strategies explained below. economizer_DT [ float , unit = \"\u00baC\", default = 0, min = 0]: For economizers type \u201cTEMPERATURE\u201d and \u201cTEMPERATURE_NOT_INTEGRATED\u201d set the temperature difference between the return air and the outside air at which the economizer starts to operate. economizer_enthalpy_limit [ float , unit = \"kJ/kg\", default = 0, min = 0]: For economizers type ENTHALPY_LIMITED set the maximun outdoor air enthalpy at which the economizer does not operate. If outside air (ventilation) is present, and the \"indoor_fan_operation\" is \"CONTINUOUS\" at the equipment, the ventilation load and the indoor fan heat are introduced into the space as \u2018uncontrolled system heat\u2019, so these loads can be viewed at the space. The following figure shows the control equations used for the different ranges as a function of space temperature. This control is the one used if the parameter \u2018control_type\u2019 is set to \u2018TEMPERATURE\u2019. Economizer The different types of economizer operation are as follows: \"TEMPERATURE\": Temperature controlled economizer will be implemented that will operate differently depending on the selected control_type, see explanation below. \"TEMPERATURE_NOT_INTEGRATED\": Temperature controlled economizer will be implemented, this economizer operates the same as the \u201cTEMPERATURE\u201d type but only works when the economizer is able to give the full sensible load of the space. \"ENTHALPY\": Enthalpy controlled economizer will be implemented, this type is only available for \"PERFECT\" control_type. It works in the same way as the \u201cTEMPERATURE\u201d type but compares the enthalpies of the return and outside air instead of the temperatures. \"ENTHALPY_LIMITED\": Enthalpy controlled economizer will be implemented, this type is only available for \"PERFECT\" control_type. It works the same as the \u201cENTHALPY\u201d type but compares the enthalpy of the outside air with the fixed value set in the \u201ceconomizer_enthalpy_limit\u201d parameter. The operation of the \"TEMPERATURE\" economizer for \"PERFECT\" control_type is as follows: If the outdoor air temperature is higher than the room temperature minus the value of the parameter \u201ceconomizer_DT\u201d, the economizer does not operate and the outdoor air flow rate is nominal. If the room has cooling load, the outdoor air temperature is lower than the room temperature minus the value of the parameter \u201ceconomizer_DT\", and by increasing the outside air flow rate the entire room load can be provided, the outside air flow rate will be the one required for this purpose. If the room has cooling load, the outdoor air temperature is lower than the room temperature minus the value of the parameter \u201ceconomizer_DT\", and the cooling load of the space cannot be provided only with outdoor air, then all the supply air will be outdoor and the coil will provide the remaining sensible cooling load. This mode will not work if the economizer type is \u201cTEMPERATURE_NOT_INTEGRATED\u201d. The operation of the economizer for \"TEMPERATURE\" or \u201cTEMPERATURE_NOT_INTEGRATED\u201d types for \"TEMPERATURE\" control_type is shown in the following figure, the outdoor air fraction, F~OA~ , changes as a function of the space air temperature along the continuous green line in the figure when the outdoor air temperature is lower than the return air temperature minus the value of the parameter \u201ceconomizer_DT\u201d, and the dashed green line will be used when outdoor air temperature is higher than the return air temperature minus the value of the parameter \u201ceconomizer_DT\u201d Example: ... system = osm.components.HVAC_DX_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"equipment\": \"HVAC_equipment\", \"supply_air_flow\": 0.417, \"outdoor_air_flow\": 0, \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"system_on_off\": \"1\", \"control_type\": \"PERFECT\" } system.set_parameters(param) Variables After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system, positive for heating and negative for cooling. Q_latent [W]: Latent heat supplied by the system, negative for dehumidification. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. state [flag]: Operation of the system: off (0), heating (1), heating at maximum capacity (2), colling (-1), cooling at maximum capacity (-2), venting (3). power [W]: Electrical power consumed by the system. EER [frac]: System efficiency ratio for cooling, defined as the total thermal load supplied divided by the electrical power consumed. COP [frac]: System efficiency ratio for heating, defined as the thermal load supplied divided by the electrical power consumed. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. T_odb [\u00baC]: Outdoor dry bulb temperature. T_owb [\u00baC]: Outdoor wet bulb temperature. T_idb [\u00baC]: Indoor dry bulb temperature, at the coil inlet of the indoor unit. T_iwb [\u00baC]: Indoor wet bulb temperature, at the coil inlet of the indoor unit. F_air [frac]: Actual supply air flow divided by nominal supply air flow. F_load [frac]: Partial load state of the system, calculated as the thermal power supplied at a given instant divided by the cooling or heating capacity at the current operation conditions. Positive for heating and negative for cooling T_supply [\u00baC]: Supply air dry bulb temperature. w_supply [g/kg]: Supply air absolute humidity. efficiency_degradation [frac]: EER or COP degradation factor obtained from the EER_expression or COP_expression of the equipment.","title":"component list HVAC systems"},{"location":"component_list_HVAC_systems/#component-list-for-hvac-system-definition","text":"","title":"Component List for HVAC system definition"},{"location":"component_list_HVAC_systems/#hvac_perfect_system","text":"Component for the perfect conditioning of a space. With this component we can obtain the heating and cooling loads (sensible and latent).","title":"HVAC_perfect_system"},{"location":"component_list_HVAC_systems/#parameters","text":"file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be controlled by this system. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. outdoor_air_flow [ math_exp , unit = \"m\u00b3/s\", default = \"0\"]: Outside air flow rate (ventilation) supplied to the space. This flow rate is only entered if the system is in operation. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. humidifying_setpoint [ math_exp , unit = \"%\", default = \"0\"]: Space relative humidity setpoint for humidification. If the relative humidity of the space is below this value, latent heat is added to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. dehumidifying_setpoint [ math_exp , unit = \"%\", default = \"100\"]: Space relative humidity setpoint for dehumidification. If the relative humidity of the space is higher this value, latent heat is removed to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. If outside air (ventilation) is present, it is introduced into the space as \u2018uncontrolled system heat\u2019, and the load values associated with the ventilation can be viewed in the space. The load supplied by the system is that required to maintain the space within the specified temperature and humidity set points, including ventilation if present. Example: ... system = osm.components.HVAC_perfect_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"outdoor_air_flow\": \"0.1\", \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"humidifying_setpoint\": \"30\", \"dehumidifying_setpoint\": \"70\", \"input_variables\":[\"f = HVAC_schedule.values\"], \"system_on_off\": \"f\" } system.set_parameters(param)","title":"Parameters"},{"location":"component_list_HVAC_systems/#variables","text":"After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system, positive for heating and negative for cooling. Q_latent [W]: Latent heat supplied by the system, positive for humidification, negative for dehumidification. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. humififying_setpoint [%]: Low relative humidity setpoint. dehumidifying_setpoint [%]: High relative humidity setpoint. state [flag]: Operation of the system: off (0), heating (1), colling (-1), venting (3).","title":"Variables"},{"location":"component_list_HVAC_systems/#hvac_dx_equipment","text":"Component to define a direct expansion air conditioning equipment. It can be used to define compact or split 1x1 units. This equipment can be used for one or more HVAC systems.","title":"HVAC_DX_equipment"},{"location":"component_list_HVAC_systems/#parameters_1","text":"nominal_air_flow [ float , unit = \"m\u00b3/s\", default = 1, min = 0]: Nominal supply air flow. nominal_total_cooling_capacity [ float , unit = \"W\", default = 0, min = 0]: Total cooling gross capacity at nominal cooling conditions. nominal_sensible_cooling_capacity [ float , unit = \"W\", default = 0, min = 0]: Sensible cooling gross capacity at nominal cooling conditions. nominal_cooling_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the equipment at nominal cooling conditions. It must include all the consumptions: compressor, external fan, etc. except the power specified in \u201cindoor_fan_power\u201d. indoor_fan_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the indoor fan, this power will be added as heat to the air stream. nominal_cooling_conditions [ float-list , unit = \"\u00baC\", default = [27, 19, 35]]: Nominal cooling conditions, in order: indoor dry bulb temperature, indoor wet bulb temperature, outdoor dry bulb temperature. total_cooling_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the total cooling capacity of the equipment in conditions different from the nominal ones. sensible_cooling_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the sensible cooling capacity of the equipment in conditions different from the nominal ones. cooling_power_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the electric power consumption at cooling full load operation of the equipment in conditions different from the nominal ones. EER_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the EER, defined as cooling total load supplied by de equipment divided by de electric power consumption, of the equipment in conditions different from the nominal ones. This expression should reflect the partial load behavior of the equipment. nominal_heating_capacity [ float , unit = \"W\", default = 0, min = 0]: Heating capacity at nominal heating conditions. nominal_heating_power [ float , unit = \"W\", default = 0, min = 0]: Electrical power consumed by the equipment at nominal heating conditions. It must include all the consumptions: compressor, external fan, etc, except the power specified in \u201cno_load_power\u201d. nominal_heating_conditions [ float-list , unit = \"\u00baC\", default = [20, 7, 6]]: Nominal heating conditions, in order: indoor dry bulb temperature, outdoor dry bulb temperature, outdoor wet bulb temperature. heating_capacity_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the heating capacity of the equipment in conditions different from the nominal ones. heating_power_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the electric power consumption at heating full load operation of the equipment in conditions different from the nominal ones. COP_expression [ math_exp , unit = \"frac\", default = \"1\"]: Mathematical expression to correct the COP, defined as heating load supplied by de equipment divided by de electric power consumption, of the equipment in conditions different from the nominal ones. This expression should reflect the partial load behavior of the equipment. indoor_fan_operation [ option , default = \"CONTINUOUS\", options = [\"CONTINUOUS\",\"CYCLING\"]]: If the value is \u201cCONTINUOUS\u201d the fan will always run, consuming electrical energy and adding heat to the air stream, even when there is no load. If we specify \u201cCYCLING\u201d the fan will run a fraction of time equal to the partial load at which the equipment operates, therefore, when there is no load there will be no consumption of the fan. dry_coil_model [ option , default = \"SENSIBLE\", options = [\"SENSIBLE\",\"TOTAL\",\"INTERPOLATION\"]]: When calculating the total and sensible capacity of the equipment under non-nominal conditions, it is possible that the total capacity is lower than the sensible capacity. In such a case it will be assumed that the coil does not dehumidify and that the total capacity is equal to the sensible capacity. We will use for both values the value of the sensible if the chosen option is \u201cSENSIBLE\u201d and the total if the chosen option is \u201cTOTAL\u201d. power_dry_coil_correction [ boolean , default = True]: When the total and sensible power are equal, dry coil, the power expression may be incorrect. If this parameter is activated the simulation will look for the wet bulb temperature that makes the total and sensible capacities equal and use that temperature in the expression that corrects the cooling power. expression_max_values [ float-list , unit = \"-\", default = [60,30,60,30,1.5,1]]: Maximum values allowed in the mathematical expressions. The order is [ T_idb [\u00baC] , T_iwb [\u00baC] , T_odb [\u00baC], T_owb [\u00baC], F_air [frac], F_load [frac] ]. If any variable exceeds these values, the maximum value is taken. expression_min_values [ float-list , unit = \"-\", default = [0,0,-30,-30,0,0]]: Minimum values allowed in the mathematical expressions. The order is [ T_idb [\u00baC] , T_iwb [\u00baC] , T_odb [\u00baC], T_owb [\u00baC], F_air [frac], F_load [frac] ]. If any variable is lower than these values, the minimum value is taken. All mathematical expressions can include the following independent variables. T_idb [\u00baC]: Indoor dry bulb temperature, at the coil inlet of the indoor unit. T_iwb [\u00baC]: Indoor wet bulb temperature, at the coil inlet of the indoor unit. T_odb [\u00baC]: Outdoor dry bulb temperature. T_owb [\u00baC]: Outdoor wet bulb temperature. F_air [frac]: Actual supply air flow divided by nominal supply air flow. \"EER_expression\" and \"COP_expression\" may also include the variable F_load , which represents the partial load state of the equipment, calculated as the thermal power supplied at a given instant divided by the cooling or heating capacity at the current operation conditions. Example: ... equipment = osm.components.HVAC_DX_equipment(\"equipment\",project) param = { \"nominal_air_flow\": 0.417, \"nominal_total_cooling_capacity\": 6000, \"nominal_sensible_cooling_capacity\": 4800, \"nominal_cooling_power\": 2400, \"indoor_fan_power\": 240, \"indoor_fan_operation\": \"CONTINUOUS\", \"total_cooling_capacity_expression\": \"0.88078 + 0.014248 * T_iwb + 0.00055436 * T_iwb**2 - 0.0075581 * T_odb + 3.2983E-05 * T_odb**2 - 0.00019171 * T_odb * T_iwb\", \"sensible_cooling_capacity_expression\": \"0.50060 - 0.046438 * T_iwb - 0.00032472 * T_iwb**2 - 0.013202 * T_odb + 7.9307E-05 * T_odb**2 + 0.069958 * T_idb - 3.4276E-05 * T_idb**2\", \"cooling_power_expression\": \"0.11178 + 0.028493 * T_iwb - 0.00041116 * T_iwb**2 + 0.021414 * T_odb + 0.00016113 * T_odb**2 - 0.00067910 * T_odb * T_iwb\", \"EER_expression\": \"0.20123 - 0.031218 * F_load + 1.9505 * F_load**2 - 1.1205 * F_load**3\", \"nominal_heating_capacity\": 6500, \"nominal_heating_power\": 2825, \"heating_capacity_expression\": \"0.81474 + 0.030682602 * T_owb + 3.2303E-05 * T_owb**2\", \"heating_power_expression\": \"1.2012 - 0.040063 * T_owb + 0.0010877 * T_owb**2\", \"COP_expression\": \"0.085652 + 0.93881 * F_load - 0.18344 * F_load**2 + 0.15897 * F_load**3\" } equipment.set_parameters(param)","title":"Parameters"},{"location":"component_list_HVAC_systems/#hvac_dx_system","text":"Component for the simulation of an air-conditioning system for a space and using equipment in direct expansion \"HVAC_DX_equipment\".","title":"HVAC_DX_system"},{"location":"component_list_HVAC_systems/#parameters_2","text":"file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be air-conditioned by this system. equipment [ component , default = \"not_defined\", component type = HVAC_DX_equipment]: Reference to the \"HVAC_DX_equipment\" component used by this system. supply_air_flow [ float , unit = \"m\u00b3/s\", default = 1, min = 0]: Supply air flow used for all the simulation. outdoor_air_flow [ float , unit = \"m\u00b3/s\", default = 0, min = 0]: Outdoor air flow used for all the simulation. The outside air is mixed with the return air from the room before it enters the indoor coil. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. control_type [ option , default = \"PERFECT\", options = [\"PERFECT\",\"TEMPERATURE\"]]: Type of control used, for the case \u2018PERFECT\u2019 the system will maintain exactly the desired temperature in the space, provided it has sufficient capacity. For the \u2018TEMPERATURE\u2019 case the power supplied by the system is calculated through a linear regulation law with the room temperature using the thermostat bandwidths, see figure below. cooling_bandwidth [ float , unit = \"\u00baC\", default = 1, min = 0]: Bandwidth used in case control_type is set to \"TEMPERATURE\" for the cooling setpoint. heating_bandwidth [ float , unit = \"\u00baC\", default = 1, min = 0]: Bandwidth used in case control_type is set to \"TEMPERATURE\" for the heating setpoint. economizer [ option , default = \"NO\", options = [\"NO\",\"TEMPERATURE\",\"TEMPERATURE_NOT_INTEGRATED\",\"ENTHALPY\",\"ENTHALPY_LIMITED\"]]: Free cooling using outside air (economizer). If the option selected is \u201cNO\u201d no economizer will be used, for the other options the economizer will be used with different control strategies explained below. economizer_DT [ float , unit = \"\u00baC\", default = 0, min = 0]: For economizers type \u201cTEMPERATURE\u201d and \u201cTEMPERATURE_NOT_INTEGRATED\u201d set the temperature difference between the return air and the outside air at which the economizer starts to operate. economizer_enthalpy_limit [ float , unit = \"kJ/kg\", default = 0, min = 0]: For economizers type ENTHALPY_LIMITED set the maximun outdoor air enthalpy at which the economizer does not operate. If outside air (ventilation) is present, and the \"indoor_fan_operation\" is \"CONTINUOUS\" at the equipment, the ventilation load and the indoor fan heat are introduced into the space as \u2018uncontrolled system heat\u2019, so these loads can be viewed at the space. The following figure shows the control equations used for the different ranges as a function of space temperature. This control is the one used if the parameter \u2018control_type\u2019 is set to \u2018TEMPERATURE\u2019. Economizer The different types of economizer operation are as follows: \"TEMPERATURE\": Temperature controlled economizer will be implemented that will operate differently depending on the selected control_type, see explanation below. \"TEMPERATURE_NOT_INTEGRATED\": Temperature controlled economizer will be implemented, this economizer operates the same as the \u201cTEMPERATURE\u201d type but only works when the economizer is able to give the full sensible load of the space. \"ENTHALPY\": Enthalpy controlled economizer will be implemented, this type is only available for \"PERFECT\" control_type. It works in the same way as the \u201cTEMPERATURE\u201d type but compares the enthalpies of the return and outside air instead of the temperatures. \"ENTHALPY_LIMITED\": Enthalpy controlled economizer will be implemented, this type is only available for \"PERFECT\" control_type. It works the same as the \u201cENTHALPY\u201d type but compares the enthalpy of the outside air with the fixed value set in the \u201ceconomizer_enthalpy_limit\u201d parameter. The operation of the \"TEMPERATURE\" economizer for \"PERFECT\" control_type is as follows: If the outdoor air temperature is higher than the room temperature minus the value of the parameter \u201ceconomizer_DT\u201d, the economizer does not operate and the outdoor air flow rate is nominal. If the room has cooling load, the outdoor air temperature is lower than the room temperature minus the value of the parameter \u201ceconomizer_DT\", and by increasing the outside air flow rate the entire room load can be provided, the outside air flow rate will be the one required for this purpose. If the room has cooling load, the outdoor air temperature is lower than the room temperature minus the value of the parameter \u201ceconomizer_DT\", and the cooling load of the space cannot be provided only with outdoor air, then all the supply air will be outdoor and the coil will provide the remaining sensible cooling load. This mode will not work if the economizer type is \u201cTEMPERATURE_NOT_INTEGRATED\u201d. The operation of the economizer for \"TEMPERATURE\" or \u201cTEMPERATURE_NOT_INTEGRATED\u201d types for \"TEMPERATURE\" control_type is shown in the following figure, the outdoor air fraction, F~OA~ , changes as a function of the space air temperature along the continuous green line in the figure when the outdoor air temperature is lower than the return air temperature minus the value of the parameter \u201ceconomizer_DT\u201d, and the dashed green line will be used when outdoor air temperature is higher than the return air temperature minus the value of the parameter \u201ceconomizer_DT\u201d Example: ... system = osm.components.HVAC_DX_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"equipment\": \"HVAC_equipment\", \"supply_air_flow\": 0.417, \"outdoor_air_flow\": 0, \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"system_on_off\": \"1\", \"control_type\": \"PERFECT\" } system.set_parameters(param)","title":"Parameters"},{"location":"component_list_HVAC_systems/#variables_1","text":"After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system, positive for heating and negative for cooling. Q_latent [W]: Latent heat supplied by the system, negative for dehumidification. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. state [flag]: Operation of the system: off (0), heating (1), heating at maximum capacity (2), colling (-1), cooling at maximum capacity (-2), venting (3). power [W]: Electrical power consumed by the system. EER [frac]: System efficiency ratio for cooling, defined as the total thermal load supplied divided by the electrical power consumed. COP [frac]: System efficiency ratio for heating, defined as the thermal load supplied divided by the electrical power consumed. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. T_odb [\u00baC]: Outdoor dry bulb temperature. T_owb [\u00baC]: Outdoor wet bulb temperature. T_idb [\u00baC]: Indoor dry bulb temperature, at the coil inlet of the indoor unit. T_iwb [\u00baC]: Indoor wet bulb temperature, at the coil inlet of the indoor unit. F_air [frac]: Actual supply air flow divided by nominal supply air flow. F_load [frac]: Partial load state of the system, calculated as the thermal power supplied at a given instant divided by the cooling or heating capacity at the current operation conditions. Positive for heating and negative for cooling T_supply [\u00baC]: Supply air dry bulb temperature. w_supply [g/kg]: Supply air absolute humidity. efficiency_degradation [frac]: EER or COP degradation factor obtained from the EER_expression or COP_expression of the equipment.","title":"Variables"},{"location":"component_list_building/","text":"Component List for building definition elements Building Base component for the definition of a building. The building is made up of a set of spaces (Space component). Parameters file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the east (Global x-axis). The coordinates of all building elements refer to the building coordinate system. albedo [ float , unit = \"frac\", default = 0.3, min = 0, max = 1]: Solar reflectivity of the ground surrounding the building. Used to calculate the solar radiation reflected to the exterior surfaces of the building. initial_temperature [ float , unit = \"\u00b0C\", default = 20]: Initial temperature of all building components at the beginning of the simulation. initial_humidity [ float , unit = \"g/kg\", default = 7.3]: Initial absolute humidity of all building spaces at the beginning of the simulation. shadow_calculation [ option , default = \"INSTANT\", options = [\"NO\",\"INSTANT\",\"INTERPOLATION\"]]: Procedure used for the exterior calculation of the shadows produced by the shading surfaces \"Shadow_surface\" and the building itself. \u201cNO\": no shadows are calculated, \"INSTANT\": Shadows are calculated for each instant of simulated time. \"INTERPOLATION\": The shadows are calculated for 36 x 18 = 648 fixed solar positions and then the shadows for every time step are obtained by interpolating on these tables. The following figure shows the building's coordinate system: Example: ... building = osm.components.Building(\"building\",project) param = { \"file_met\": \"met\" \"azimuth\": 90, \"albedo\": 0.4 } building.set_parameters(param) functions The Building component include the following functions: show3D(hide, opacity, coordinate_system, space) : Displays in Jupyter an interactive 3D visualization of the building (using pyVista). hide : (default value: []) List of the types of components that we do not want to show, for example [\u201cInterior_surface\u201d, \"Underground_surface\"] will hide these two types of components. opacity : Opacity of the surfaces, 1 (default value) for totally opaque and 0 for totally transparent. coordinate_system : Coordinate system in which the building will be displayed, \u201cglobal\u201d (default value), \u201clocal\u201d the coordinate system of the building. space : (default value: \u201call\u201d) If a space name is specified, the rest of the spaces will be shown dimmed (opacity = 0.25). show3D_shadows(date) : Calculates and displays an interactive 3D visualization of the building with the shadows occurring for the date specified. date : Python datetime object specifying a specific date. See next figure as example. Space_type Component used to define the type of space. This component will be referenced by all spaces that are of the same type. This component defines the internal loads and some of the functional characteristics of the space. Parameters input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. people_density [ math_exp , unit = \"p/m\u00b2\", default = \"0.1\"]: Occupancy density, defined in persons per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below people_sensible [ float , unit = \"W/p\", default = 70, min = 0]: Sensible heat generated by each of the occupants of the space. people_latent [ float , unit = \"W/p\", default = 35, min = 0]: Latent heat generated by each of the occupants of the space. people_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Long wave radiant fraction of heat generated by occupants. The rest of the heat is assumed to be convective. light_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Lighting density, defined as the electrical lighting power [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. light_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Short wave radiant fraction of heat generated by lights. The rest of the heat is assumed to be convective. other_gains_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Other gains density, defined as the heat generated by other gains (Household appliances, office automation, miscellaneous electrical equipment, etc.) [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. other_gains_radiant_fraction [ float , unit = \"frac\", default = 0.5, min = 0, max = 1]: Long wave radiant fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. other_gains_latent_fraction [ float , unit = \"frac\", default = 0.0, min = 0, max = 1]: Latent fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. infiltration [ math_exp , unit = \"1/h\", default = \"1\"]: Air flow rate infiltrated into the space from outside and expressed in volumes of the space per hour. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. Assuming that the variation of occupancy, lighting and other loads has been defined in a \"Year_schedule\" component, named \"schedule\" with values between 0 and 1, the following example would capture that variation. Example: ... office_space = osm.components.Space_type(\"office_space\",project) param = { \"input_variables\": [\"f = schedule.values\"] \"people_density\": \"0.1*f\", \"light_density\": \"10*f\", \"other_gains_density\": \"4.2*f\", \"other_gains_radiant_fraction\": 0.6, \"infiltration\": \"0.5\" } office_space.set_parameters(param) Variables After the simulation we will have the following variables of this component: people_convective [W/m\u00b2]: Convective heat due to occupancy. people_radiant [W/m\u00b2]: Radiant heat (long wave) due to occupancy. people_latent [W/m\u00b2]: Latent heat due to occupancy. light_convective [W/m\u00b2]: Convective heat due to lighting. light_radiant [W/m\u00b2]: Radiant heat (short wave) due to lighting. other_gains_convective [W/m\u00b2]: Convective heat due to other gains. other_gains_radiant [W/m\u00b2]: Radiant heat (long wave) due to other gains. other_gains_latent [W/m\u00b2]: Latent heat due to other gains. infiltration_rate [1/h]: Air flow rate infiltrated into the space from outside, expressed in volumes of the space per hour. Space Component used to define each of the building's spaces. The spaces of a building are each of the volumes of the building where we can find a different temperatures. The spaces will be referenced by the different surfaces that comprise them. Parameters building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. space_type [ component , default = \"not_defined\", component type = Space_type]: Reference to the \"Space_type\" component that defines its occupational and functional characteristics. floor_area [ float , unit = \"m\u00b2\", default = 1, min = 0]: Floor area of the space. volume [ float , unit = \"m\u00b3\", default = 1, min = 0]: Volume of the space. furniture_weight [ float , unit = \"kg/m\u00b2\", default = 10, min = 0]: Weight of the furniture in the space. Used to increase the thermal inertia of the space which will be added to that of the air (for the furniture a specific heat of 1000 J/kg\u00b7K will be used). Example: ... space_1 = osm.components.Space(\"space_1\",project) param = { \"building\": \"building\", \"space_type\": \"office_space\", \"floor_area\": 30, \"volume\": 90 } space_1.set_parameters(param) Variables After the simulation we will have the following variables of this component: temperatura [\u00b0C]: Space dry air temperatura. abs_humidity [g/kg]: Absolute space air humidity. rel_humidity [%]: Relative space air humidity. people_convective [W]: Convective heat due to occupancy. people_radiant [W]: Radiant heat (long wave) due to occupancy. people_latent [W]: Latent heat due to occupancy. light_convective [W]: Convective heat due to lighting. light_radiant [W]: Radiant heat (short wave) due to lighting. other_gains_convective [W]: Convective heat due to other gains. other_gains_radiant [W]: Radiant heat (long wave) due to other gains. other_gains_latent [W]: Latent heat due to other gains. solar_direct_gains [W]: Direct solar radiation gains. infiltration_flow [m\u00b3/s]: Air flow rate infiltrated into the space from outside. infiltration_sensible_heat [W]: Sensible heat due to air infiltration from outdoor. surfaces_convective [W]: Convective heat flux exchanged between interior surfaces and space air. delta_int_energy [W]: Increase of internal energy of the space (air and furniture). u_system_sensible_heat [W]: Sensible heat introduced by uncontrolled systems in space. Spaces can collect airflows from various types of systems, those that are not capable of controlling the room temperature are called \u2018uncontrolled systems\u2019. For example, a flow of outside air, a flow from a dedicated outdoor air system, etc. u_system_sensible_latent [W]: Latent heat introduced by uncontrolled systems in space. system_sensible_heat [W]: Sensible heat introduced by the system responsible for space control. Positive for heating and negative for cooling. system_sensible_latent [W]: Latent heat introduced by control system in space. Positive for humidification and negative for dehumidification. Exterior_surface Component to define the exterior surfaces of the building: vertical or inclined walls and horizontal or inclined roofs. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figures show the surface coordinate system versus the building coordinate system for rectangular or polygonal surfaces. Example: ... north_wall = osm.components.Exterior_surface(\"north_wall\",project) param = { \"ref_point\": [8,0,-6], \"width\": 8, \"height\": 2.7, \"azimuth\": 180, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"space\": \"space_1\" } north_wall.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface. Interior_surface Component to define the interior surfaces of the building: vertical or inclined interior walls and slabs between floors. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [2,2], min = 0]: Convective film coefficients of the 0 an 1 side, respectively. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_wall = osm.components.Interior_surface(\"interior_wall\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"spaces\": [\"space_0\", \"space_1\"] } interior_wall.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer \"0\" surface and those ending in 1 to the \"1\" surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. Underground_surface Component define the surfaces in contact with the ground. Floors or vertical undergorund enclosures. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float , unit = \"W/m\u00b2K\", default = 2, min = 0]: Convective film coefficient of interior surface. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... floor = osm.components.Underground_surface(\"floor\",project) param = { \"shape\": \"POLYGON\", \"ref_point\": [0,0,0], \"x_polygon\": [0,8,8,0], \"y_polygon\": [0,0,6,6], \"azimuth\": 0, \"altitude\": -90, \"construction\": \"Multilayer wall\", \"space\": \"space_1\" } floor.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the underground surface and those ending in 1 to the interior surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv1 [W/m\u00b2]: Convective heat flux at the ineterior surface. q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the interior surface due to internal gains. q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due to internal gains. q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. Virtual_surface Virtual surfaces are used to define gaps between two spaces. Spaces in OpenSimula must be completely enclosed by surfaces for the radiant exchange calculation to work correctly. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_hole = osm.components.Virtual_surface(\"interior_hole\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"spaces\": [\"space_0\",\"space_1\"] } interior_hole.set_parameters(param) Opening Component for defining openings in exterior surfaces, e.g. windows or doors. These elements must be rectangular. Parameters surface [ component , default = \"not_defined\", component type = Exterior_surface]: Reference to the \"Exterior_surface\" in which it is located. width [ float , unit = \"m\", default = 1, min = 0]: Width of the opening. height [ float , unit = \"m\", default = 1, min = 0]: Height of the opening. ref_point [ float-list , unit = \"m\", default = [0,0]]: Two-dimensional coordinate of the opening reference point in the exterior wall coordinate system. The reference point is the lower left corner of the opening viewed from the outside. opening_type [ component , default = \"not_defined\", component type = Opening_type]: Reference to the \"Opening_type\" component that defines its composition. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figure show geometrical definition of the opening in the surface coordinate system. Example: ... south_window = osm.components.Opening(\"south_window\",project) param = { \"surface\": \"south_wall\" \"ref_point\": [2,1], \"width\": 3, \"height\": 1.3, \"opening_type\": \"double_glazed_window\" } south_window.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd [W/m\u00b2]: Conductive heat flux. q_sol_dir_trans [W/m\u00b2]: Direct solar radiation passing through into space. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_sol01, q_sol10 [W/m\u00b2]: Solar heat flux appearing on surface \"i\" due to the absorption of solar radiation on surface \"j\". q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface. Shadow_surface Component for defining shading surfaces external to the building. Parameters building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. Example: ... overhang = osm.components.Shadow_surface(\"overhang\") param = { \"building\": \"Building\", \"ref_point\": [0,-1,2.7], \"width\": 8, \"height\": 1, \"azimuth\": 0, \"altitude\": 90 }, overhang.set_parameters(param)","title":"Component list building"},{"location":"component_list_building/#component-list-for-building-definition-elements","text":"","title":"Component List for building definition elements"},{"location":"component_list_building/#building","text":"Base component for the definition of a building. The building is made up of a set of spaces (Space component).","title":"Building"},{"location":"component_list_building/#parameters","text":"file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the east (Global x-axis). The coordinates of all building elements refer to the building coordinate system. albedo [ float , unit = \"frac\", default = 0.3, min = 0, max = 1]: Solar reflectivity of the ground surrounding the building. Used to calculate the solar radiation reflected to the exterior surfaces of the building. initial_temperature [ float , unit = \"\u00b0C\", default = 20]: Initial temperature of all building components at the beginning of the simulation. initial_humidity [ float , unit = \"g/kg\", default = 7.3]: Initial absolute humidity of all building spaces at the beginning of the simulation. shadow_calculation [ option , default = \"INSTANT\", options = [\"NO\",\"INSTANT\",\"INTERPOLATION\"]]: Procedure used for the exterior calculation of the shadows produced by the shading surfaces \"Shadow_surface\" and the building itself. \u201cNO\": no shadows are calculated, \"INSTANT\": Shadows are calculated for each instant of simulated time. \"INTERPOLATION\": The shadows are calculated for 36 x 18 = 648 fixed solar positions and then the shadows for every time step are obtained by interpolating on these tables. The following figure shows the building's coordinate system: Example: ... building = osm.components.Building(\"building\",project) param = { \"file_met\": \"met\" \"azimuth\": 90, \"albedo\": 0.4 } building.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#functions","text":"The Building component include the following functions: show3D(hide, opacity, coordinate_system, space) : Displays in Jupyter an interactive 3D visualization of the building (using pyVista). hide : (default value: []) List of the types of components that we do not want to show, for example [\u201cInterior_surface\u201d, \"Underground_surface\"] will hide these two types of components. opacity : Opacity of the surfaces, 1 (default value) for totally opaque and 0 for totally transparent. coordinate_system : Coordinate system in which the building will be displayed, \u201cglobal\u201d (default value), \u201clocal\u201d the coordinate system of the building. space : (default value: \u201call\u201d) If a space name is specified, the rest of the spaces will be shown dimmed (opacity = 0.25). show3D_shadows(date) : Calculates and displays an interactive 3D visualization of the building with the shadows occurring for the date specified. date : Python datetime object specifying a specific date. See next figure as example.","title":"functions"},{"location":"component_list_building/#space_type","text":"Component used to define the type of space. This component will be referenced by all spaces that are of the same type. This component defines the internal loads and some of the functional characteristics of the space.","title":"Space_type"},{"location":"component_list_building/#parameters_1","text":"input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. people_density [ math_exp , unit = \"p/m\u00b2\", default = \"0.1\"]: Occupancy density, defined in persons per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below people_sensible [ float , unit = \"W/p\", default = 70, min = 0]: Sensible heat generated by each of the occupants of the space. people_latent [ float , unit = \"W/p\", default = 35, min = 0]: Latent heat generated by each of the occupants of the space. people_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Long wave radiant fraction of heat generated by occupants. The rest of the heat is assumed to be convective. light_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Lighting density, defined as the electrical lighting power [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. light_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Short wave radiant fraction of heat generated by lights. The rest of the heat is assumed to be convective. other_gains_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Other gains density, defined as the heat generated by other gains (Household appliances, office automation, miscellaneous electrical equipment, etc.) [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. other_gains_radiant_fraction [ float , unit = \"frac\", default = 0.5, min = 0, max = 1]: Long wave radiant fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. other_gains_latent_fraction [ float , unit = \"frac\", default = 0.0, min = 0, max = 1]: Latent fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. infiltration [ math_exp , unit = \"1/h\", default = \"1\"]: Air flow rate infiltrated into the space from outside and expressed in volumes of the space per hour. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. Assuming that the variation of occupancy, lighting and other loads has been defined in a \"Year_schedule\" component, named \"schedule\" with values between 0 and 1, the following example would capture that variation. Example: ... office_space = osm.components.Space_type(\"office_space\",project) param = { \"input_variables\": [\"f = schedule.values\"] \"people_density\": \"0.1*f\", \"light_density\": \"10*f\", \"other_gains_density\": \"4.2*f\", \"other_gains_radiant_fraction\": 0.6, \"infiltration\": \"0.5\" } office_space.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables","text":"After the simulation we will have the following variables of this component: people_convective [W/m\u00b2]: Convective heat due to occupancy. people_radiant [W/m\u00b2]: Radiant heat (long wave) due to occupancy. people_latent [W/m\u00b2]: Latent heat due to occupancy. light_convective [W/m\u00b2]: Convective heat due to lighting. light_radiant [W/m\u00b2]: Radiant heat (short wave) due to lighting. other_gains_convective [W/m\u00b2]: Convective heat due to other gains. other_gains_radiant [W/m\u00b2]: Radiant heat (long wave) due to other gains. other_gains_latent [W/m\u00b2]: Latent heat due to other gains. infiltration_rate [1/h]: Air flow rate infiltrated into the space from outside, expressed in volumes of the space per hour.","title":"Variables"},{"location":"component_list_building/#space","text":"Component used to define each of the building's spaces. The spaces of a building are each of the volumes of the building where we can find a different temperatures. The spaces will be referenced by the different surfaces that comprise them.","title":"Space"},{"location":"component_list_building/#parameters_2","text":"building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. space_type [ component , default = \"not_defined\", component type = Space_type]: Reference to the \"Space_type\" component that defines its occupational and functional characteristics. floor_area [ float , unit = \"m\u00b2\", default = 1, min = 0]: Floor area of the space. volume [ float , unit = \"m\u00b3\", default = 1, min = 0]: Volume of the space. furniture_weight [ float , unit = \"kg/m\u00b2\", default = 10, min = 0]: Weight of the furniture in the space. Used to increase the thermal inertia of the space which will be added to that of the air (for the furniture a specific heat of 1000 J/kg\u00b7K will be used). Example: ... space_1 = osm.components.Space(\"space_1\",project) param = { \"building\": \"building\", \"space_type\": \"office_space\", \"floor_area\": 30, \"volume\": 90 } space_1.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_1","text":"After the simulation we will have the following variables of this component: temperatura [\u00b0C]: Space dry air temperatura. abs_humidity [g/kg]: Absolute space air humidity. rel_humidity [%]: Relative space air humidity. people_convective [W]: Convective heat due to occupancy. people_radiant [W]: Radiant heat (long wave) due to occupancy. people_latent [W]: Latent heat due to occupancy. light_convective [W]: Convective heat due to lighting. light_radiant [W]: Radiant heat (short wave) due to lighting. other_gains_convective [W]: Convective heat due to other gains. other_gains_radiant [W]: Radiant heat (long wave) due to other gains. other_gains_latent [W]: Latent heat due to other gains. solar_direct_gains [W]: Direct solar radiation gains. infiltration_flow [m\u00b3/s]: Air flow rate infiltrated into the space from outside. infiltration_sensible_heat [W]: Sensible heat due to air infiltration from outdoor. surfaces_convective [W]: Convective heat flux exchanged between interior surfaces and space air. delta_int_energy [W]: Increase of internal energy of the space (air and furniture). u_system_sensible_heat [W]: Sensible heat introduced by uncontrolled systems in space. Spaces can collect airflows from various types of systems, those that are not capable of controlling the room temperature are called \u2018uncontrolled systems\u2019. For example, a flow of outside air, a flow from a dedicated outdoor air system, etc. u_system_sensible_latent [W]: Latent heat introduced by uncontrolled systems in space. system_sensible_heat [W]: Sensible heat introduced by the system responsible for space control. Positive for heating and negative for cooling. system_sensible_latent [W]: Latent heat introduced by control system in space. Positive for humidification and negative for dehumidification.","title":"Variables"},{"location":"component_list_building/#exterior_surface","text":"Component to define the exterior surfaces of the building: vertical or inclined walls and horizontal or inclined roofs.","title":"Exterior_surface"},{"location":"component_list_building/#parameters_3","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figures show the surface coordinate system versus the building coordinate system for rectangular or polygonal surfaces. Example: ... north_wall = osm.components.Exterior_surface(\"north_wall\",project) param = { \"ref_point\": [8,0,-6], \"width\": 8, \"height\": 2.7, \"azimuth\": 180, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"space\": \"space_1\" } north_wall.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_2","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface.","title":"Variables"},{"location":"component_list_building/#interior_surface","text":"Component to define the interior surfaces of the building: vertical or inclined interior walls and slabs between floors.","title":"Interior_surface"},{"location":"component_list_building/#parameters_4","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [2,2], min = 0]: Convective film coefficients of the 0 an 1 side, respectively. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_wall = osm.components.Interior_surface(\"interior_wall\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"spaces\": [\"space_0\", \"space_1\"] } interior_wall.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_3","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer \"0\" surface and those ending in 1 to the \"1\" surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps.","title":"Variables"},{"location":"component_list_building/#underground_surface","text":"Component define the surfaces in contact with the ground. Floors or vertical undergorund enclosures.","title":"Underground_surface"},{"location":"component_list_building/#parameters_5","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float , unit = \"W/m\u00b2K\", default = 2, min = 0]: Convective film coefficient of interior surface. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... floor = osm.components.Underground_surface(\"floor\",project) param = { \"shape\": \"POLYGON\", \"ref_point\": [0,0,0], \"x_polygon\": [0,8,8,0], \"y_polygon\": [0,0,6,6], \"azimuth\": 0, \"altitude\": -90, \"construction\": \"Multilayer wall\", \"space\": \"space_1\" } floor.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_4","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the underground surface and those ending in 1 to the interior surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv1 [W/m\u00b2]: Convective heat flux at the ineterior surface. q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the interior surface due to internal gains. q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due to internal gains. q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps.","title":"Variables"},{"location":"component_list_building/#virtual_surface","text":"Virtual surfaces are used to define gaps between two spaces. Spaces in OpenSimula must be completely enclosed by surfaces for the radiant exchange calculation to work correctly.","title":"Virtual_surface"},{"location":"component_list_building/#parameters_6","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_hole = osm.components.Virtual_surface(\"interior_hole\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"spaces\": [\"space_0\",\"space_1\"] } interior_hole.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#opening","text":"Component for defining openings in exterior surfaces, e.g. windows or doors. These elements must be rectangular.","title":"Opening"},{"location":"component_list_building/#parameters_7","text":"surface [ component , default = \"not_defined\", component type = Exterior_surface]: Reference to the \"Exterior_surface\" in which it is located. width [ float , unit = \"m\", default = 1, min = 0]: Width of the opening. height [ float , unit = \"m\", default = 1, min = 0]: Height of the opening. ref_point [ float-list , unit = \"m\", default = [0,0]]: Two-dimensional coordinate of the opening reference point in the exterior wall coordinate system. The reference point is the lower left corner of the opening viewed from the outside. opening_type [ component , default = \"not_defined\", component type = Opening_type]: Reference to the \"Opening_type\" component that defines its composition. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figure show geometrical definition of the opening in the surface coordinate system. Example: ... south_window = osm.components.Opening(\"south_window\",project) param = { \"surface\": \"south_wall\" \"ref_point\": [2,1], \"width\": 3, \"height\": 1.3, \"opening_type\": \"double_glazed_window\" } south_window.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_5","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd [W/m\u00b2]: Conductive heat flux. q_sol_dir_trans [W/m\u00b2]: Direct solar radiation passing through into space. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_sol01, q_sol10 [W/m\u00b2]: Solar heat flux appearing on surface \"i\" due to the absorption of solar radiation on surface \"j\". q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface.","title":"Variables"},{"location":"component_list_building/#shadow_surface","text":"Component for defining shading surfaces external to the building.","title":"Shadow_surface"},{"location":"component_list_building/#parameters_8","text":"building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. Example: ... overhang = osm.components.Shadow_surface(\"overhang\") param = { \"building\": \"Building\", \"ref_point\": [0,-1,2.7], \"width\": 8, \"height\": 1, \"azimuth\": 0, \"altitude\": 90 }, overhang.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/","text":"Component List for constructive elements Material Component to describe the thermal characteristics of the materials used in the enclosures (Construction component). Parameters conductivity [ float , unit = \"W/(n\u00b7K)\", default = 1, min = 0]: Material thermal conductivity. density [ float , unit = \"kg/m\u00b3\", default = 1000, min = 0.001]: Material Density. specific_heat [ float , unit = \"J/(kg\u00b7K)\", default = 1000, min = 0.001]: Material specific heat. use_resistance [ boolean , default = False]: If the value is \"False\", conductivity, density and specific heat will be used. For \"True\" value, thermal resistance, density and specific heat will be used. thermal_resistance [ float , unit = \"(m\u00b2\u00b7K)/W\", default = 1, min = 0]: Thermal resistance of material layer. Example: ... material = pro.new_component(\"Material\",\"concrete\") param = { \"conductivity\": 1.95, \"density\": 2240, \"specific_heat\": 900, } material.set_parameters(param) Construction Component to describe the composition of the different layers (Material component) of an enclosure. Parameters solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity for surfaces 1 and 2. materials [[ component-list , default = [], component type = Material]]: Materials list for each of the layers, defined from surface 1 to 2. thicknesses [ float-list , unit = \"m\", default = [], min = 0]: Thicknesses of each of the layers defined in the \"materials\" parameter. Must have the same number of elements as the \"materials\" parameter. Example: ... construction = pro.new_component(\"Construction\",\"Multilayer wall\") param = { \"solar_alpha\": [0.8, 0.8], \"materials\": [\"Gypsum board\",\"EPS board\",\"Heavyweight concrete\",\"EPS board\",\"Stucco\"], \"thicknesses\": [0.016, 0.076, 0.203, 0.076, 0.025], } construction.set_parameters(param) Glazing Component to describe the glazings. Default values are those of a clear single pane of 6 mm thickness. Parameters solar_tau [ float , unit = \"frac\", default = 0.849, min = 0, max = 1]: Solar transmittance of glass at normal incidence. solar_rho [ float-list , unit = \"frac\", default = [0.077,0.077], min = 0, max = 1]: Solar reflectance of glass at normal incidence, for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.837,0.837], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. g [ float-list , unit = \"frac\", default = [0.867093,0.867093], min = 0, max = 1]: Solar factor at normal incidence, calculated according to EN 410:2011, for surfaces 1 and 2. U [ float , unit = \"W/m\u00b2K\", default = 5.686, min = 0]: Thermal transmittance of glazing calculated according to EN 673:2011. f_tau_nor [[ math-exp , default = \"1.3186 * cos_theta ** 3 - 3.5251 * cos_theta **2 + 3.2065 * cos_theta\"]: Normalised curve of the variation of solar transmittance, depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). f_1_minus_rho_nor [[ math-exp-list , default = [\"1.8562 * cos_theta ** 3 - 4.4739 * cos_theta ** 2 + 3.6177 * cos_theta\", \"1.8562 * cos_theta ** 3 - 4.4739 * cos_theta ** 2 + 3.6177 * cos_theta\"]]: Normalised curve of the variation for (1 - solar reflectance), depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). To obtain the solar transmittance at an angle of incidence theta, the component shall multiply the value at normal incidence solar_tau by the value of the curve f_tau_nor . The following pictures show the solar transmittance of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. To obtain the angular reflectance for each side, multiply the normal incidence value solar_rho by the value of the expression: (1 - f_1_minus_rho_nor ). We use the normalisation of (1 - reflectance) since the reflectance tends to 1 when the angle of incidence tends to 90\u00ba and the value we use to normalise is the reflectance at normal incidence (0\u00ba). The following pictures show the solar reflectance and (1- solar reflectance) of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. Example: ... glazing = pro.new_component(\"Glazing\",\"Double_glazing\") param = { \"solar_tau\": 0.731, \"solar_rho\": [0.133,0.133], \"g\": [0.776, 0.776], \"U\": 2.914, \"f_tau_nor\": \"-0.3516 * cos_theta ** 3 - 0.6031 * cos_theta ** 2 +1.9424 * cos_theta\", \"f_1_minus_rho_nor: [\"0.9220 * cos_theta ** 3 - 2.8551 * cos_theta ** 2 + 2.9327 * cos_theta\", \"0.9220 * cos_theta ** 3 - 2.8551 * cos_theta ** 2 + 2.9327 * cos_theta\"] } glazing.set_parameters(param) Frame Component to describe the thermal properties of frames used in Opening_types. Parameters solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. thermal_resistance [ float , unit = \"m\u00b2K/W\", default = 0.2, min = 0]: Average surface-to-surface thermal resistance of the frame. Example: ... frame = pro.new_component(\"Frame\",\"metal_frame\") param = { \"solar_alpha\": [0.6, 0.6], \"thermal_resistance\": 0.35 } frame.set_parameters(param) Opening_type Component for defining the composition of fa\u00e7ade openings in buildings. For example windows or doors. Parameters glazing [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Glazing\" component used. frame [ component , default = \"not_defined\", component type = Frame]: Reference to the \"Frame\" component used. construction [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Construction\" component used. If the opaque part of an opening is defined by a constraction, it will always be assumed to be in steady state for thermal calculations. glazing_fraction [ float , unit = \"frac\", default = 0.9, min = 0, max = 1]: Fraction of the opening made up of a glazing. frame_fraction [ float , unit = \"frac\", default = 0.1, min = 0, max = 1]: Fraction of the opening made up of a frame. if the glazing_fraction plus the frame_fraction is less than 1 the rest of the area is assumed to be opaque and formed by the defined cosntruction. Example: ... double_glazed_window = pro.new_component(\"Opening_type\",\"double_glazed_window\") param = { \"glazing\": \"double_glazing\", \"frame\": \"wood_frame\", \"glazing_fraction\": 0.8, \"frame_fraction\": 0.2 } double_glazed_window.set_parameters(param)","title":"Component list constructions"},{"location":"component_list_constructions/#component-list-for-constructive-elements","text":"","title":"Component List for constructive elements"},{"location":"component_list_constructions/#material","text":"Component to describe the thermal characteristics of the materials used in the enclosures (Construction component).","title":"Material"},{"location":"component_list_constructions/#parameters","text":"conductivity [ float , unit = \"W/(n\u00b7K)\", default = 1, min = 0]: Material thermal conductivity. density [ float , unit = \"kg/m\u00b3\", default = 1000, min = 0.001]: Material Density. specific_heat [ float , unit = \"J/(kg\u00b7K)\", default = 1000, min = 0.001]: Material specific heat. use_resistance [ boolean , default = False]: If the value is \"False\", conductivity, density and specific heat will be used. For \"True\" value, thermal resistance, density and specific heat will be used. thermal_resistance [ float , unit = \"(m\u00b2\u00b7K)/W\", default = 1, min = 0]: Thermal resistance of material layer. Example: ... material = pro.new_component(\"Material\",\"concrete\") param = { \"conductivity\": 1.95, \"density\": 2240, \"specific_heat\": 900, } material.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#construction","text":"Component to describe the composition of the different layers (Material component) of an enclosure.","title":"Construction"},{"location":"component_list_constructions/#parameters_1","text":"solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity for surfaces 1 and 2. materials [[ component-list , default = [], component type = Material]]: Materials list for each of the layers, defined from surface 1 to 2. thicknesses [ float-list , unit = \"m\", default = [], min = 0]: Thicknesses of each of the layers defined in the \"materials\" parameter. Must have the same number of elements as the \"materials\" parameter. Example: ... construction = pro.new_component(\"Construction\",\"Multilayer wall\") param = { \"solar_alpha\": [0.8, 0.8], \"materials\": [\"Gypsum board\",\"EPS board\",\"Heavyweight concrete\",\"EPS board\",\"Stucco\"], \"thicknesses\": [0.016, 0.076, 0.203, 0.076, 0.025], } construction.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#glazing","text":"Component to describe the glazings. Default values are those of a clear single pane of 6 mm thickness.","title":"Glazing"},{"location":"component_list_constructions/#parameters_2","text":"solar_tau [ float , unit = \"frac\", default = 0.849, min = 0, max = 1]: Solar transmittance of glass at normal incidence. solar_rho [ float-list , unit = \"frac\", default = [0.077,0.077], min = 0, max = 1]: Solar reflectance of glass at normal incidence, for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.837,0.837], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. g [ float-list , unit = \"frac\", default = [0.867093,0.867093], min = 0, max = 1]: Solar factor at normal incidence, calculated according to EN 410:2011, for surfaces 1 and 2. U [ float , unit = \"W/m\u00b2K\", default = 5.686, min = 0]: Thermal transmittance of glazing calculated according to EN 673:2011. f_tau_nor [[ math-exp , default = \"1.3186 * cos_theta ** 3 - 3.5251 * cos_theta **2 + 3.2065 * cos_theta\"]: Normalised curve of the variation of solar transmittance, depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). f_1_minus_rho_nor [[ math-exp-list , default = [\"1.8562 * cos_theta ** 3 - 4.4739 * cos_theta ** 2 + 3.6177 * cos_theta\", \"1.8562 * cos_theta ** 3 - 4.4739 * cos_theta ** 2 + 3.6177 * cos_theta\"]]: Normalised curve of the variation for (1 - solar reflectance), depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). To obtain the solar transmittance at an angle of incidence theta, the component shall multiply the value at normal incidence solar_tau by the value of the curve f_tau_nor . The following pictures show the solar transmittance of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. To obtain the angular reflectance for each side, multiply the normal incidence value solar_rho by the value of the expression: (1 - f_1_minus_rho_nor ). We use the normalisation of (1 - reflectance) since the reflectance tends to 1 when the angle of incidence tends to 90\u00ba and the value we use to normalise is the reflectance at normal incidence (0\u00ba). The following pictures show the solar reflectance and (1- solar reflectance) of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. Example: ... glazing = pro.new_component(\"Glazing\",\"Double_glazing\") param = { \"solar_tau\": 0.731, \"solar_rho\": [0.133,0.133], \"g\": [0.776, 0.776], \"U\": 2.914, \"f_tau_nor\": \"-0.3516 * cos_theta ** 3 - 0.6031 * cos_theta ** 2 +1.9424 * cos_theta\", \"f_1_minus_rho_nor: [\"0.9220 * cos_theta ** 3 - 2.8551 * cos_theta ** 2 + 2.9327 * cos_theta\", \"0.9220 * cos_theta ** 3 - 2.8551 * cos_theta ** 2 + 2.9327 * cos_theta\"] } glazing.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#frame","text":"Component to describe the thermal properties of frames used in Opening_types.","title":"Frame"},{"location":"component_list_constructions/#parameters_3","text":"solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. thermal_resistance [ float , unit = \"m\u00b2K/W\", default = 0.2, min = 0]: Average surface-to-surface thermal resistance of the frame. Example: ... frame = pro.new_component(\"Frame\",\"metal_frame\") param = { \"solar_alpha\": [0.6, 0.6], \"thermal_resistance\": 0.35 } frame.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#opening_type","text":"Component for defining the composition of fa\u00e7ade openings in buildings. For example windows or doors.","title":"Opening_type"},{"location":"component_list_constructions/#parameters_4","text":"glazing [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Glazing\" component used. frame [ component , default = \"not_defined\", component type = Frame]: Reference to the \"Frame\" component used. construction [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Construction\" component used. If the opaque part of an opening is defined by a constraction, it will always be assumed to be in steady state for thermal calculations. glazing_fraction [ float , unit = \"frac\", default = 0.9, min = 0, max = 1]: Fraction of the opening made up of a glazing. frame_fraction [ float , unit = \"frac\", default = 0.1, min = 0, max = 1]: Fraction of the opening made up of a frame. if the glazing_fraction plus the frame_fraction is less than 1 the rest of the area is assumed to be opaque and formed by the defined cosntruction. Example: ... double_glazed_window = pro.new_component(\"Opening_type\",\"double_glazed_window\") param = { \"glazing\": \"double_glazing\", \"frame\": \"wood_frame\", \"glazing_fraction\": 0.8, \"frame_fraction\": 0.2 } double_glazed_window.set_parameters(param)","title":"Parameters"},{"location":"component_list_files/","text":"Component List for reading files File_met component used to read and manage weather files. Creating the necessary weather variables to be used by other components. Parameters file_type [ option , default = \"MET\", options = [\"MET\",\"TMY3\",\"TMY2\"]]: Weather file type. \"MET\": MET format. .MET format (CTE documentation) , \"TMY3\" TMY3 format TMY3 format description , \"TMY2\" TMY2 format TMY2 format description file_name [ string , default = \"name.met\"]: Name of the weather file containing the data. tilted_diffuse_model [ option , default = \"PEREZ\", options = [\"PEREZ\",\"REINDL\",\"HAY-DAVIES\", \"ISOTROPIC\"]]: Model used for the calculation of diffuse solar radiation on inclined surfaces. The simplest model is the isotropic model (\u201cISOTROPIC\u201d) which only takes into account uniform diffuse radiation. The Hay-Davies model includes the influence of the circumsolar component and the Reindl and Perez model also includes the effect of the horizon brightening component. More information about diffuse models on tilted surface Example: ... met = pro.new_component(\"File_met\",\"met\") met.parameter(\"file_name\").value = \"examples/met_files/sevilla.met\" To generate the variables in the simulation time step, the values are obtained by linear interpolation of the data available in the meteorological file. The variables associated with the solar position are calculated, not obtained from the values stored in the file. Variables temperature [\u00b0C]: Dry bulb temperature. sky_temperature [\u00b0C]: Sky temperature, for radiant heat exchange (read from MET files, calculated in TMY3 files). underground_temperature [\u00b0C]: Ground temperature, to be used as the temperature imposed on the outer surface of the enclosures in contact with the ground (currently not read from the file, it is calculated as the annual average air temperature). abs_humidity [g/kg]: Air absolute humidity (calculated). rel_humidity [%]: Air relative humidity. dew_point_temp [\u00b0C]: Dew point air temperature (calculated). wet_bulb_temp [\u00b0C]: Wet bulb air temperature (calculated). sol_hour [h]: Solar hour of the day (calculated). sol_direct [W/m\u00b2]: Direct solar irradiance over horizontal surface. sol_diffuse [W/m\u00b2]: Diffuse solar irradiance over horizontal surface. sol_azimuth [\u00b0]: Solar azimuth (degrees from south: E-, W+) (calculated). sol_altitude [\u00b0]: Solar altitude (degrees) (calculated). wind_speed [m/s]: Wind speed. wind_direction [\u00b0]: Wind direction (degrees from north: E+, W-). pressure [Pa]: Ambient absolute pressure (read from TMY3 files, calculated using standard atmosphere for MET files). total_cloud_cover [%]: Percentage of the sky covered by all the visible clouds (read from TMY3 files, 0 for MET files). opaque_cloud_cover [%]: Percentage of the sky covered, used for infrared radiation an sky temperature estimation (read from TMY3 files, 0 for MET files). File_data Component to read temporary data files and use them as simulation variables. Parameters file_name [ string , default = \"data.csv\"]: Name of the file containing the data. file_type [ option , default = \"CSV\", options = [\"CSV\",\"EXCEL\"]]: Data file type. \"CSV\", file with the values separated by comma. It must contain a first row with the variable names and from the second row the values for each time step. \"EXCEL\": excel file with a single sheet and the same format as described for CSV files. file_step [ option , default = \"SIMULATION\", options = [\"SIMULATION\",\"OWN\"]]: Time step of the data file. The \"SIMULATION\" option assumes that each of the rows in the data file correspond to the time steps of the project simulation. The \"OWN\" option will be used when the time step of the data stored in the data file is different from the one used in the simulation. The parameters \"initial_time\" and \"time_step\" define the time step of the data in the file. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial time of the data file with format \"DD/MM/YYYY hh:mm:ss\". Only used for the \"OWN\" option of the \"file_step\" parameter. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds for the data file. Only used for the \"OWN\" option of the \"file_step\" parameter. If we use the \"SIMULATION\" option of the \"file_step\" parameter and the number of data in the file is less than the number of time steps during the simulation, to obtain the variables we will go back to the beginning of the data file each time the end of the file is reached. the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. If we use the \"OWN\" option of the \"file_step\" parameter and the simulated time instant is before or after the time instants collected in the file, the first value will be taken if it is before and the last one if it is after. Otherwise a linear interpolation will be performed to obtain the values of each of the simulation steps. Example: ... datas = osm.new_component(\"File_dat\",\"datas\") param = { \"file_name\": \"examples/input_files/data_example.csv\", \"file_type\": \"CSV\", \"file_step\": \"SIMULATION\", } datas.set_parameters(param) Variables The component will generate a variable for each of the columns of the data file, using as name and unit for the variable the first row of the file. The unit must be written after the name in square brackets. For example for the following CSV file: n, temperature [\u00baC], humidity [kg/kg as] 1, 15.1, 0.00792 2, 14.6, 0.00788 3, 14.1, 0.00783 4, 13.5, 0.00772 5, 13.0, 0.00766 ... Three variables will be created with names: n, temperature and humidity. And with the units indicated in square brackets.","title":"Component list files"},{"location":"component_list_files/#component-list-for-reading-files","text":"","title":"Component List for reading files"},{"location":"component_list_files/#file_met","text":"component used to read and manage weather files. Creating the necessary weather variables to be used by other components.","title":"File_met"},{"location":"component_list_files/#parameters","text":"file_type [ option , default = \"MET\", options = [\"MET\",\"TMY3\",\"TMY2\"]]: Weather file type. \"MET\": MET format. .MET format (CTE documentation) , \"TMY3\" TMY3 format TMY3 format description , \"TMY2\" TMY2 format TMY2 format description file_name [ string , default = \"name.met\"]: Name of the weather file containing the data. tilted_diffuse_model [ option , default = \"PEREZ\", options = [\"PEREZ\",\"REINDL\",\"HAY-DAVIES\", \"ISOTROPIC\"]]: Model used for the calculation of diffuse solar radiation on inclined surfaces. The simplest model is the isotropic model (\u201cISOTROPIC\u201d) which only takes into account uniform diffuse radiation. The Hay-Davies model includes the influence of the circumsolar component and the Reindl and Perez model also includes the effect of the horizon brightening component. More information about diffuse models on tilted surface Example: ... met = pro.new_component(\"File_met\",\"met\") met.parameter(\"file_name\").value = \"examples/met_files/sevilla.met\" To generate the variables in the simulation time step, the values are obtained by linear interpolation of the data available in the meteorological file. The variables associated with the solar position are calculated, not obtained from the values stored in the file.","title":"Parameters"},{"location":"component_list_files/#variables","text":"temperature [\u00b0C]: Dry bulb temperature. sky_temperature [\u00b0C]: Sky temperature, for radiant heat exchange (read from MET files, calculated in TMY3 files). underground_temperature [\u00b0C]: Ground temperature, to be used as the temperature imposed on the outer surface of the enclosures in contact with the ground (currently not read from the file, it is calculated as the annual average air temperature). abs_humidity [g/kg]: Air absolute humidity (calculated). rel_humidity [%]: Air relative humidity. dew_point_temp [\u00b0C]: Dew point air temperature (calculated). wet_bulb_temp [\u00b0C]: Wet bulb air temperature (calculated). sol_hour [h]: Solar hour of the day (calculated). sol_direct [W/m\u00b2]: Direct solar irradiance over horizontal surface. sol_diffuse [W/m\u00b2]: Diffuse solar irradiance over horizontal surface. sol_azimuth [\u00b0]: Solar azimuth (degrees from south: E-, W+) (calculated). sol_altitude [\u00b0]: Solar altitude (degrees) (calculated). wind_speed [m/s]: Wind speed. wind_direction [\u00b0]: Wind direction (degrees from north: E+, W-). pressure [Pa]: Ambient absolute pressure (read from TMY3 files, calculated using standard atmosphere for MET files). total_cloud_cover [%]: Percentage of the sky covered by all the visible clouds (read from TMY3 files, 0 for MET files). opaque_cloud_cover [%]: Percentage of the sky covered, used for infrared radiation an sky temperature estimation (read from TMY3 files, 0 for MET files).","title":"Variables"},{"location":"component_list_files/#file_data","text":"Component to read temporary data files and use them as simulation variables.","title":"File_data"},{"location":"component_list_files/#parameters_1","text":"file_name [ string , default = \"data.csv\"]: Name of the file containing the data. file_type [ option , default = \"CSV\", options = [\"CSV\",\"EXCEL\"]]: Data file type. \"CSV\", file with the values separated by comma. It must contain a first row with the variable names and from the second row the values for each time step. \"EXCEL\": excel file with a single sheet and the same format as described for CSV files. file_step [ option , default = \"SIMULATION\", options = [\"SIMULATION\",\"OWN\"]]: Time step of the data file. The \"SIMULATION\" option assumes that each of the rows in the data file correspond to the time steps of the project simulation. The \"OWN\" option will be used when the time step of the data stored in the data file is different from the one used in the simulation. The parameters \"initial_time\" and \"time_step\" define the time step of the data in the file. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial time of the data file with format \"DD/MM/YYYY hh:mm:ss\". Only used for the \"OWN\" option of the \"file_step\" parameter. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds for the data file. Only used for the \"OWN\" option of the \"file_step\" parameter. If we use the \"SIMULATION\" option of the \"file_step\" parameter and the number of data in the file is less than the number of time steps during the simulation, to obtain the variables we will go back to the beginning of the data file each time the end of the file is reached. the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. If we use the \"OWN\" option of the \"file_step\" parameter and the simulated time instant is before or after the time instants collected in the file, the first value will be taken if it is before and the last one if it is after. Otherwise a linear interpolation will be performed to obtain the values of each of the simulation steps. Example: ... datas = osm.new_component(\"File_dat\",\"datas\") param = { \"file_name\": \"examples/input_files/data_example.csv\", \"file_type\": \"CSV\", \"file_step\": \"SIMULATION\", } datas.set_parameters(param)","title":"Parameters"},{"location":"component_list_files/#variables_1","text":"The component will generate a variable for each of the columns of the data file, using as name and unit for the variable the first row of the file. The unit must be written after the name in square brackets. For example for the following CSV file: n, temperature [\u00baC], humidity [kg/kg as] 1, 15.1, 0.00792 2, 14.6, 0.00788 3, 14.1, 0.00783 4, 13.5, 0.00772 5, 13.0, 0.00766 ... Three variables will be created with names: n, temperature and humidity. And with the units indicated in square brackets.","title":"Variables"},{"location":"component_list_schedules/","text":"Component List to define schedules Day_schedule Component used for simple definition of daily variation of a value. Parameters time_steps [ int-list , unit = \"s\", default = [3600], min = 1]: time steps where the values change. values [ float-list , default = [0,10]]: Values for the time steps defined in the previous parameter. It must always contain one more element than the parameter \"time_steps\". interpolation [ option , default = \"STEP\", options = [\"STEP\",\"LINEAR\"]]: Procedure used to obtain the values at each of the simulation instants. \"STEP\": The value changes in the form of a step. \"LINEAR\": The value changes linearly between the values defined in the schedule. Example: ... day = pro.new_component(\"Day_schedule\",\"day\") param = { \"time_steps\": [7200,3600], \"values\": [10,20,15], \"interpolation\": \"STEP\" } day.set_parameters(param) The first three hours of the day (7200 s) the value is 10, the next hour (3600 s) 20, and from that instant to the end of the day 15. Using \"interpolation\": \"LINEAR\" this would be the result Week_schedule Component used for simple definition of week variation of a value. It uses to Day_schedule components Parameters days-schedules [ component-list , default = [\"not_defined\"], component type = Day_schedule]: Day_schedule used for the different days of the week. It can contain one value (it will be the one used for all days) or seven values, the Day_schedules for Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday. Example: ... week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) The Day_schedule called \"working_day\" will be used from Monday to Friday, \"holiday_day\" will be used on Saturday an Sunday. Year_schedule Component used for simple definition of year variation of a value. It uses to Week_schedule components Parameters periods [ string-list , default = [\"01/06\"]]: Ends of the different periods. Each of them must be in \"dd:mm\" format. The begining of the first period is \"01/01\" and the end of the last period \"31/12\" weeks_schedules [ component-list , default = [\"not_defined\",\"not_defined]]: Week_schedule to be used in the different periods. It must always contain one more element than the parameter \"periods\". Example: ... year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [\"31/07\",\"31/08\"], \"weeks_schedules\": [\"working_week\",\"holiday_week\",\"working_week\"] } year.set_parameters(param) The Week_schedule called \"holiday_week\" will be used for August and \"working_week\" for the rest of the year. Variables values : values obtained using year, weeks and days schedules for each of the simulation time steps. If the project to be simulated has the daylight_saving parameter activated, summer time will be taken into account when obtaining the hourly values by shifting the values by one hour during the daylight saving period.","title":"Component list schedules"},{"location":"component_list_schedules/#component-list-to-define-schedules","text":"","title":"Component List to define schedules"},{"location":"component_list_schedules/#day_schedule","text":"Component used for simple definition of daily variation of a value.","title":"Day_schedule"},{"location":"component_list_schedules/#parameters","text":"time_steps [ int-list , unit = \"s\", default = [3600], min = 1]: time steps where the values change. values [ float-list , default = [0,10]]: Values for the time steps defined in the previous parameter. It must always contain one more element than the parameter \"time_steps\". interpolation [ option , default = \"STEP\", options = [\"STEP\",\"LINEAR\"]]: Procedure used to obtain the values at each of the simulation instants. \"STEP\": The value changes in the form of a step. \"LINEAR\": The value changes linearly between the values defined in the schedule. Example: ... day = pro.new_component(\"Day_schedule\",\"day\") param = { \"time_steps\": [7200,3600], \"values\": [10,20,15], \"interpolation\": \"STEP\" } day.set_parameters(param) The first three hours of the day (7200 s) the value is 10, the next hour (3600 s) 20, and from that instant to the end of the day 15. Using \"interpolation\": \"LINEAR\" this would be the result","title":"Parameters"},{"location":"component_list_schedules/#week_schedule","text":"Component used for simple definition of week variation of a value. It uses to Day_schedule components","title":"Week_schedule"},{"location":"component_list_schedules/#parameters_1","text":"days-schedules [ component-list , default = [\"not_defined\"], component type = Day_schedule]: Day_schedule used for the different days of the week. It can contain one value (it will be the one used for all days) or seven values, the Day_schedules for Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday. Example: ... week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) The Day_schedule called \"working_day\" will be used from Monday to Friday, \"holiday_day\" will be used on Saturday an Sunday.","title":"Parameters"},{"location":"component_list_schedules/#year_schedule","text":"Component used for simple definition of year variation of a value. It uses to Week_schedule components","title":"Year_schedule"},{"location":"component_list_schedules/#parameters_2","text":"periods [ string-list , default = [\"01/06\"]]: Ends of the different periods. Each of them must be in \"dd:mm\" format. The begining of the first period is \"01/01\" and the end of the last period \"31/12\" weeks_schedules [ component-list , default = [\"not_defined\",\"not_defined]]: Week_schedule to be used in the different periods. It must always contain one more element than the parameter \"periods\". Example: ... year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [\"31/07\",\"31/08\"], \"weeks_schedules\": [\"working_week\",\"holiday_week\",\"working_week\"] } year.set_parameters(param) The Week_schedule called \"holiday_week\" will be used for August and \"working_week\" for the rest of the year.","title":"Parameters"},{"location":"component_list_schedules/#variables","text":"values : values obtained using year, weeks and days schedules for each of the simulation time steps. If the project to be simulated has the daylight_saving parameter activated, summer time will be taken into account when obtaining the hourly values by shifting the values by one hour during the daylight saving period.","title":"Variables"},{"location":"component_list_utils/","text":"Component List for various utilities Calculator Component to perform calculations with the variables of other components. Parameters input_variables [ variable_list , default = []]: List of variables from other components used in this component. They can appear in the expressions of the \u201coutput_expressions\u201d parameter. output_variables [ string_list , default = []]: List of output variable names. output_units [ string_list , default = []]: List of output variable units. output_expressions [ math_exp_list , default = []]: List of output variable mathematical expressions. Variables The component will generate a variable for each of the input variables specified in \"input_variables\" and \"output_variables\" using the mathematical expressions for the calculation in each time step. Example: ... calc = osm.new_component(\"Calculator\",\"unit_change\") param = { \"input_variables\": [\"T = met.temperature\", \"w = met.abs_humidity\"], \"output_variables\": [\"T_F\",\"W_kg\"], \"output_units\": [\"\u00baF\",\"kg/kg a.s.\"], \"output_expressions\": [\"T * 9/5 + 32\", \"w / 1000\"] } calc.set_parameters(param) Four variables will be created with names: T, w, T_F and W_kg, two from input_variables and two from output_variables.","title":"Component list utils"},{"location":"component_list_utils/#component-list-for-various-utilities","text":"","title":"Component List for various utilities"},{"location":"component_list_utils/#calculator","text":"Component to perform calculations with the variables of other components.","title":"Calculator"},{"location":"component_list_utils/#parameters","text":"input_variables [ variable_list , default = []]: List of variables from other components used in this component. They can appear in the expressions of the \u201coutput_expressions\u201d parameter. output_variables [ string_list , default = []]: List of output variable names. output_units [ string_list , default = []]: List of output variable units. output_expressions [ math_exp_list , default = []]: List of output variable mathematical expressions.","title":"Parameters"},{"location":"component_list_utils/#variables","text":"The component will generate a variable for each of the input variables specified in \"input_variables\" and \"output_variables\" using the mathematical expressions for the calculation in each time step. Example: ... calc = osm.new_component(\"Calculator\",\"unit_change\") param = { \"input_variables\": [\"T = met.temperature\", \"w = met.abs_humidity\"], \"output_variables\": [\"T_F\",\"W_kg\"], \"output_units\": [\"\u00baF\",\"kg/kg a.s.\"], \"output_expressions\": [\"T * 9/5 + 32\", \"w / 1000\"] } calc.set_parameters(param) Four variables will be created with names: T, w, T_F and W_kg, two from input_variables and two from output_variables.","title":"Variables"},{"location":"developer_guide/","text":"Developer Guide Under development ...","title":"Developer guide"},{"location":"developer_guide/#developer-guide","text":"Under development ...","title":"Developer Guide"},{"location":"getting_started/","text":"Getting Started The best environment to start using OpenSimula is with Jupyter notebooks or Google Colab . We recommend the use of JupyterLab Desktop Installing OpenSiumula To install OpenSimula you can use any of the methods that Python makes possible. For example, to install using pip we must use: pip install OpenSimula OpenSimula uses in different parts of the code the following Python packages, which will be installed automatically when OpenSimula is installed: NumPy pandas SciPy shapely psychrolib pyvista[jupyter] plotly dash dash_bootstrap_components dash_ag_grid triangle First example First we are going to define a Python dictionary that contains the information of our project: project_dict = { \"name\": \"First example project\", \"time_step\": 3600, \"n_time_steps\": 24*365, \"initial_time\": \"01/01/2001 00:00:00\", \"components\": [ { \"type\": \"Day_schedule\", \"name\": \"working_day\", \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0], \"interpolation\": \"STEP\", }, { \"type\": \"Day_schedule\", \"name\": \"holiday_day\", \"time_steps\": [], \"values\": [0], \"interpolation\": \"STEP\", }, { \"type\": \"Week_schedule\", \"name\": \"working_week\", \"days_schedules\": [ \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"holiday_day\", \"holiday_day\", ], }, { \"type\": \"Week_schedule\", \"name\": \"holiday_week\", \"days_schedules\": [\"holiday_day\"], }, { \"type\": \"Year_schedule\", \"name\": \"year\", \"periods\": [\"01/08\", \"01/09\"], \"weeks_schedules\": [\"working_week\", \"holiday_week\", \"working_week\"], }, ], } All OpenSimula projects must contain the project definition parameters and a key called components with the list of project components. The project parameters in this example are: name : project name. time_step : Time step used for simulation in seconds. n_time_step : Number of simulated time steps. initial_time : Initial time for the simulation. The project contains two components of type Day_schedule , two of type Week_schedule and one of type Year_schedule . The first Day_schedule component called working_day describes how a value changes throughout the day. The day is divided into five periods described in the time_steps parameter: 8*3600 s (00:00 to 8:00). 5*3600 s (8:00 to 13:00) 2*3600 s (13:00 to 15:00) 4*3600 s (15:00 to 19:00) Rest of day (19:00 to 24:00) The values for these periods are defined in the values parameter, in our example they are 0, 100, 0, 0, 80 and 0. the STEP value of the interpolation parameter sets the value to change in steps from 0 to 100 at 8:00. The other option for the interpolation parameter is LINEAR which would perform a linear interpolation to obtain the values at each simulation instant. The other Day_schedule component called holiday_day sets a single all-day period with value 0. The Week_schedule components define two different types of weeks, the working_week in which a Day_schedule reference is set through the days_schedules parameter setting working_day for Monday through Friday and holiday_day for Saturday and Sunday. The holiday_week component sets a single Day_schedule reference to be used for all days of the week equal to holiday_day . Finally, the Year_schedule named year sets three annual periods using the periods parameter and their respective references to Week_schedule using weeks_schedules parameter which are: January 1st to August 1st: working_week . August 1st to September 1st: holiday_week . September 1st to December 31st: working_week . To simulate this project that we have defined, we first import the OpenSimula.Simulation object to create a simulation environment in the sim variable, a project within that simulation environment called pro . We load the project reading the dictionary that we have explained previously with the read_dict function available for projects and we simulate it using the simulate() function. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"First example project\") pro.read_dict(project_dict) pro.simulate() We will get the following in response to these commands: Reading project data from dictonary Reading completed. Checking project: First example project ok Simulating First example project: ... 10%: N_iter: 1.00 20%: N_iter: 1.00 30%: N_iter: 1.00 40%: N_iter: 1.00 50%: N_iter: 1.00 60%: N_iter: 1.00 70%: N_iter: 1.00 80%: N_iter: 1.00 90%: N_iter: 1.00 100%: N_iter: 1.00 Simulation completed. After the simulation, each of the components will have its time variables calculated. In our case the year component has a temporary variable called values that we can obtain. the Simulation.plot function can be used to draw an interactive graph (plotly library), the first argument are the dates of the simulation steps (pro.dates() return the array of simulated dates) and the second a list of the varibles to draw. variables = [pro.component(\"year\").variable(\"values\")] sim.plot(pro.dates(), variables) We obtain an interactive graph with the 8760 values on which we can zoom in to show, as an example, the first week of the year.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"The best environment to start using OpenSimula is with Jupyter notebooks or Google Colab . We recommend the use of JupyterLab Desktop","title":"Getting Started"},{"location":"getting_started/#installing-opensiumula","text":"To install OpenSimula you can use any of the methods that Python makes possible. For example, to install using pip we must use: pip install OpenSimula OpenSimula uses in different parts of the code the following Python packages, which will be installed automatically when OpenSimula is installed: NumPy pandas SciPy shapely psychrolib pyvista[jupyter] plotly dash dash_bootstrap_components dash_ag_grid triangle","title":"Installing OpenSiumula"},{"location":"getting_started/#first-example","text":"First we are going to define a Python dictionary that contains the information of our project: project_dict = { \"name\": \"First example project\", \"time_step\": 3600, \"n_time_steps\": 24*365, \"initial_time\": \"01/01/2001 00:00:00\", \"components\": [ { \"type\": \"Day_schedule\", \"name\": \"working_day\", \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0], \"interpolation\": \"STEP\", }, { \"type\": \"Day_schedule\", \"name\": \"holiday_day\", \"time_steps\": [], \"values\": [0], \"interpolation\": \"STEP\", }, { \"type\": \"Week_schedule\", \"name\": \"working_week\", \"days_schedules\": [ \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"holiday_day\", \"holiday_day\", ], }, { \"type\": \"Week_schedule\", \"name\": \"holiday_week\", \"days_schedules\": [\"holiday_day\"], }, { \"type\": \"Year_schedule\", \"name\": \"year\", \"periods\": [\"01/08\", \"01/09\"], \"weeks_schedules\": [\"working_week\", \"holiday_week\", \"working_week\"], }, ], } All OpenSimula projects must contain the project definition parameters and a key called components with the list of project components. The project parameters in this example are: name : project name. time_step : Time step used for simulation in seconds. n_time_step : Number of simulated time steps. initial_time : Initial time for the simulation. The project contains two components of type Day_schedule , two of type Week_schedule and one of type Year_schedule . The first Day_schedule component called working_day describes how a value changes throughout the day. The day is divided into five periods described in the time_steps parameter: 8*3600 s (00:00 to 8:00). 5*3600 s (8:00 to 13:00) 2*3600 s (13:00 to 15:00) 4*3600 s (15:00 to 19:00) Rest of day (19:00 to 24:00) The values for these periods are defined in the values parameter, in our example they are 0, 100, 0, 0, 80 and 0. the STEP value of the interpolation parameter sets the value to change in steps from 0 to 100 at 8:00. The other option for the interpolation parameter is LINEAR which would perform a linear interpolation to obtain the values at each simulation instant. The other Day_schedule component called holiday_day sets a single all-day period with value 0. The Week_schedule components define two different types of weeks, the working_week in which a Day_schedule reference is set through the days_schedules parameter setting working_day for Monday through Friday and holiday_day for Saturday and Sunday. The holiday_week component sets a single Day_schedule reference to be used for all days of the week equal to holiday_day . Finally, the Year_schedule named year sets three annual periods using the periods parameter and their respective references to Week_schedule using weeks_schedules parameter which are: January 1st to August 1st: working_week . August 1st to September 1st: holiday_week . September 1st to December 31st: working_week . To simulate this project that we have defined, we first import the OpenSimula.Simulation object to create a simulation environment in the sim variable, a project within that simulation environment called pro . We load the project reading the dictionary that we have explained previously with the read_dict function available for projects and we simulate it using the simulate() function. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"First example project\") pro.read_dict(project_dict) pro.simulate() We will get the following in response to these commands: Reading project data from dictonary Reading completed. Checking project: First example project ok Simulating First example project: ... 10%: N_iter: 1.00 20%: N_iter: 1.00 30%: N_iter: 1.00 40%: N_iter: 1.00 50%: N_iter: 1.00 60%: N_iter: 1.00 70%: N_iter: 1.00 80%: N_iter: 1.00 90%: N_iter: 1.00 100%: N_iter: 1.00 Simulation completed. After the simulation, each of the components will have its time variables calculated. In our case the year component has a temporary variable called values that we can obtain. the Simulation.plot function can be used to draw an interactive graph (plotly library), the first argument are the dates of the simulation steps (pro.dates() return the array of simulated dates) and the second a list of the varibles to draw. variables = [pro.component(\"year\").variable(\"values\")] sim.plot(pro.dates(), variables) We obtain an interactive graph with the 8760 values on which we can zoom in to show, as an example, the first week of the year.","title":"First example"},{"location":"user_guide/","text":"User Guide In this guide you will find information on how to use OpenSimula from an environment that can run Python. The best environment to start using OpenSimula is with Jupyter notebooks . Simulation environment Once we have OpenSimula installed, the base component to work with OpenSimula is the \u201cSimulation\u201d object that we must import and create an instance of it, which we will call \u201csim\u201d. import OpenSimula.Simulation as Simulation sim = Simulation() The simulation object will be used to create and manage the different projects. To create a new project in our simulation environment we will use the new_project(name) function. the project name is stored in a parameter of the project that can be changed later. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project 1\") Simulation functions The following is a list of the most useful functions of the Simulation object: new_project(name) : Create a new project in our simulation environment, with name parameter \"name\". del_project(pro) : Deletes the \"pro\" project. project(name) : Returns the project with name parameter \"name\". Returns \"None\" if not found. project_list() : Returns the list of projects in simulation environment. project_dataframe() : Returns pandas DataFrame with all the projects and its parameters as columns. plot(dates,variables,names=[],axis=[],frequency=None,value=\"mean\") : Draw variables graph (using plotly). dates is the array of dates to be used on the x-axis (can be obtained with the dates() function of the projects). Varibles is a list of variables to be plotted, each one in a serie. Names is the list of names for the series (if empty variables names will be used).frequency [ None , \"H\", \"D\", \"M\", \"Y\"] is the frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\") and value [ \"mean\" ,\"max\",\"min\",\"sum\"], if we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each point (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). project_editor() : When used in Jupyter, it generates a form with a table that allows you to create new projects, delete existing ones and edit the parameters of each project, as shown in the following image. Projects Projects contain a set of components defining a case that can be temporarily simulated. Project parameters name [ string ]: Name of the project. description [ string , default = \"Description of the project\"]: Description of the project. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds used for simulation. n_time_steps [ int , default = 8760, min = 1]: Number of time steps to simulate. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial simulation time with format \"DD/MM/YYYY hh:mm:ss\". daylight_saving [ boolean , default = False]: Taking into account daylight saving time in the simulation. If its value is False, the whole simulation is performed in winter time without daylight saving. If True, the daylight saving time change will be taken into account, mainly in the components that define schedules. daylight_saving_start_time [ string , default = \"25/03/2001 02:00:00\"]: daylight saving start time, with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. daylight_saving_end_time [ string , default = \"28/10/2001 02:00:00\"]: daylight saving start time, time with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. n_max_iteration [ int , default = 1000, min = 1]: Maximum number of iterations in each time step. If after this number of iterations the instant has not converged, it is passed to the next time instant. simulation_order [ string-list , default = [ \"Space_type\", \"Exterior_surface\", \"Underground_surface\", \"Interior_surface\", \"Virtual_surface\", \"Shadow_surface\", \"Opening\", \"Space\", \"Building\", \"HVAC_perfect_system\", \"HVAC_DX_system\", \"Calculator\" ]]: Order used for the types of components in the simulation loops. All components not specified are added at the beginning and those defined in this list are added at the end in the established order. Example of project for the simulation of the first week of june with 15 min time step. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project one\") pro.parameter(\"description\").value = \"Project example\" pro.parameter(\"time_step\").value = 60*15 pro.parameter(\"n_time_steps\").value = 24*4*7 pro.parameter(\"initial_time\").value = \"01/06/2001 00:00:00\" Project and component parameters can be changed one by one or in bulk using a dictionary and the set_parameter(dictonary) function, or interactively using the project and component editors. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project one\") param = { \"description\": \"Project example\", \"time_step\": 60*15, \"n_time_steps\": 24*4*7, \"initial_time\": \"01/06/2001 00:00:00\" } pro.set_parameters(param) Project functions The following is a list of the most useful functions of the Project object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the project. parameter_dict() : Returns a dictonary with all the parameters of the project. set_parameters(dict) : Change project parameters using python dictonary. new_component(type, name) : Creates a new component of the type specified in the first argument and with the name of the second argument. del_component(comp) : Deletes the \"comp\" component. component(name) : Returns the component with name parameter \"name\". Returns \"None\" if not found. component_list() : Returns the list of components of the project. component_dataframe() : Returns pandas DataFrame with the components of the project. read_dict(dict) : Read python dictonary \"dict\" with the parameters of the project and a list of component to create. See Getting started for definition dictonary example. After reading the dictonary check() function is executed. read_json(file) : Read json file to define the project. Json file must have the format used for dictionaries in the read_dic function. After reading the file check() function is executed. write_dict() : Return python dictonary with the definition of the project. The default values of the parameters are written explicitly. write_json(file) : Write json file that define the project. The written json file is exactly the same as the dictionary generated by the \"write_dict\" function. check() : Returns the list of errors after checking all the components. All the errors returned are also printed. simulate(show_percentage = 10) : Perform the time simulation of the project, calculating all the varibles of the components. Once the simulation has started, an informative progress message will be printed every time the percentage set in the show_percentage parameter is exceeded (its default value is 10%), and the average number of iterations performed in each time step, for that percentage, will also be displayed. simulation_dataframe() : Returns pandas DataFrame with information from the latest simulation. For each time step it includes the number of iterations performed and the name of the last component that forced the iteration. dates() : Returns numpy array with the date of each simulation instant, using winter time without daylight saving. component_editor(type) : When used in Jupyter, it generates a form with a table that allows you to create new compenents, delete existing ones and edit the parameters of each component. If the type is specified, a table with only the components of that type will be displayed. If no type is included or type = \u201call\u201d all components will be displayed but only with the common parameters. Following image shows an example of the component editor: the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. Components Components are objects included in projects that contain parameters and variables. Component list describe the different types of Components in OpenSimula. As an example, we will see how to create three different types of components and how to manage them in our project. this code is a continuation of the definition of the previous project. ... working_day = pro.new_component(\"Day_schedule\",\"working_day\") param = { \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0] } working_day.set_parameters(param) holiday_day = pro.new_component(\"Day_schedule\",\"holiday_day\") param = { \"time_steps\": [], \"values\": [0] } holiday_day.set_parameters(param) week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [], \"weeks_schedules\": [\"week\"] } year.set_parameters(param) To create the components we use project \"new_component\" function. For example, to create a Day_schedule we will use pro.new_component(\"Day_schedule\",\"name\") . Where the first argument is the type of component and the second the name of the component. After creating the components we can modify any of their parameters. After defining a project with its components, changing the parameters one by one or using a dictionary to define it, we can check if there is any error using the check() function and perform the temporary simulation with the simulate() function. ... pro.check() pro.simulate() Python shell output: Checking project: Project 1 ok Simulating Project 1: ... 10%: N_iter: 1.00 20%: N_iter: 1.00 30%: N_iter: 1.00 40%: N_iter: 1.00 50%: N_iter: 1.00 60%: N_iter: 1.00 70%: N_iter: 1.00 80%: N_iter: 1.00 90%: N_iter: 1.00 100%: N_iter: 1.00 Simulation completed. The list of parameters of a project can be obtained in pandas DataFrame format using the project functions parameter_dataframe() . For the components we can get parameters and variables dataframes with parameter_dataframe() and variable_dataframe() . To obtain the list of components in a project with the parameters as columns use the function component_dataframe(comp_type=\"all\") . In the \"type\" argument of the function we can indicate the type of components we want to list (for example: \"Day_schedule\"), or indicate \"all\" (this is the default value), which will show all components including only the three parameters common to all components: \"name\", \"type\" and \"description\". With Jupyter notebooks or Google Collab, writing the python variable of a project the parameter and component dataframe will be shown, and writing one component python variable parameter and variable dataframe will be shown. Next example shows the parameter and component dataframes of our project: ... pro Jupyter shell: Components functions The following is a list of the most useful functions of the Components object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the component. set_parameters(dict) : Change component parameters using python dictonary. check() : Returns the list of errors after checking the components. All the errors returned are also printed. variable(name) : Returns the variable \"name\". variable_dataframe(units=False, frequency=None, value=\"mean\", interval=None, pos_neg_columns=[]) : Returns a pandas dataframe with all the variables of the component. This is the meaning of the arguments of the variable_dataframe function. (In bold the default values): units [ False /True]: Include de units in the name of the variable. frequency [ None , \"H\", \"D\", \"M\", \"Y\"]: Frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\"). value [ \"mean\" ,\"max\",\"min\",\"sum\"]: If we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each row (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). interval [ None ,[start_date, end_date]]: List with the start and end dates of the period to be included in the dataframe, if the value is None all values are included. pos_neg_columns [[]]: List of variables that will be included in separate columns positive and negative values, with \"column_name\"_pos and \"column_name\"_neg as names. Parameters Parameters are used to define the characteristics that make up the projects and components. The parameters will be defined as Python dictionary keys (or json format files), that is the format we will use in the examples shown in the documentation. Parameters can be of different types depending on the type of information they contain: Parameter_string: String of characters, e.g.: \"name\": \"Project 1\" . Parameter_boolean: True or False value, e.g.: \"simplified_definition\": False . Parameter_int: Integer value, e.g.: \"time_step\": 3600 . Parameter_float: Floating point value, e.g.: \"conductivity\": 1.8 . Parameter_options: character string included in a closed option list, e.g.: \"file_type\": \"EXCEL\" . Parameter_component: Reference to another component, e.g.: \"meteo_file\": \"Sevilla\" . Parameter_variable: This parameter is used to create a variable in the component by copying it from another component. A new name is defined and the unit will be taken from the original variable. e.g.: \"input_variables\": \"t_1 = meteo.temperature\" , a variable called \"t_1\" will be created which is a copy of the variable \"temperature\" of the component \"meteo\". Parameter_math_exp: parameter defining a mathematical expression. Each of the components knows how to use that mathematical expression within its simulation process. e.g.: \"people_density\": \"0.1 * f\" , this parameter states that the people density shall be calculated by multiplying by 0.1 a variable called \"f\" that the component must include. The mathematical expressions must be written in Python. All of the above types can also be defined as parameter lists, giving rise to the following types: Parameter_string_list: List of String of characters, e.g.: \"authors\": [\"Juan F.\", \"Luis\", \"Ismael\"] . Parameter_boolean_list: List of True or False values, e.g.: \"operated\": [True, True, False] . Parameter_int_list: List of integer values, e.g.: \"people\": [24, 12, 18] . Parameter_float_list: List of floating point values, e.g.: \"solar_alpha\": [0.8, 0.75] . Parameter_options_list: List of character strings included in a closed option list, e.g.: \"day_types\": [\"MONDAY\", \"TUESDAY\"] . Parameter_component_list: List of references to another components, e.g.: \"materials\": [\"Cement mortar\", \"Hollow brick\"] . Parameter_variable_list: List of parameters used to copy a list of variables. e.g.: \"input_variables\": [\"t_1 = meteo.temperature\",\"hr = meteo.relative_humidity\"] . Parameter_math_exp_list: List of mathematical expressions. e.g.: \"curves\": [\"0.3 * t + 20\",\"0.04 * t**2 - 0.2 * t + 3 \"] . The Parameter_component, Parameter_variable, Parameter_component_list and Parameter_variable_list can refer to a component of the same project, in that case it is only necessary to put the name of the component, or a component of another project. In this last case we must write \"project_name->component_name\". e.g. \"meteo_file\": \"Project 1->Sevilla\" . To get or set the value of a parameter we must use the attribute \"value\" of the parameter. If the parameter contain a list we can set/get each value using index, for example: pro.component(\"week\").parameter(\"days_schedules\").value[0] will return \"working_day\" ... pro.component(\"year\").parameter(\"description\").value = \"Example of year schedule\" pro.component(\"year\").parameter(\"description\").value Jupyter output: 'Example of year schedule' Variables Variables are elements included in the components to store the temporal information generated during the simulation. Variables are lists of floating values, one for each instant of simulated time. To access the values of a variable we use the values attribute which returns a numpy.array object (NumPy library array object). ... pro.component(\"year\").variable(\"values\").values Jupyter output: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ... 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Output is truncated. View as a scrollable element or open in a text editor. Adjust cell output settings... The variable_dataframe(units, frequency, value, interval, pos_neg_columns) method of the components returns a pandas dataframe with all the variables of the component. As an example we can see how to obtain the monthly average values of the variables of a meteorological file (File_met component): ... pro.component(\"met_file\").variable_dataframe(frequency=\"M\",value=\"mean\") Jupyter shell:","title":"User guide"},{"location":"user_guide/#user-guide","text":"In this guide you will find information on how to use OpenSimula from an environment that can run Python. The best environment to start using OpenSimula is with Jupyter notebooks .","title":"User Guide"},{"location":"user_guide/#simulation-environment","text":"Once we have OpenSimula installed, the base component to work with OpenSimula is the \u201cSimulation\u201d object that we must import and create an instance of it, which we will call \u201csim\u201d. import OpenSimula.Simulation as Simulation sim = Simulation() The simulation object will be used to create and manage the different projects. To create a new project in our simulation environment we will use the new_project(name) function. the project name is stored in a parameter of the project that can be changed later. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project 1\")","title":"Simulation environment"},{"location":"user_guide/#simulation-functions","text":"The following is a list of the most useful functions of the Simulation object: new_project(name) : Create a new project in our simulation environment, with name parameter \"name\". del_project(pro) : Deletes the \"pro\" project. project(name) : Returns the project with name parameter \"name\". Returns \"None\" if not found. project_list() : Returns the list of projects in simulation environment. project_dataframe() : Returns pandas DataFrame with all the projects and its parameters as columns. plot(dates,variables,names=[],axis=[],frequency=None,value=\"mean\") : Draw variables graph (using plotly). dates is the array of dates to be used on the x-axis (can be obtained with the dates() function of the projects). Varibles is a list of variables to be plotted, each one in a serie. Names is the list of names for the series (if empty variables names will be used).frequency [ None , \"H\", \"D\", \"M\", \"Y\"] is the frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\") and value [ \"mean\" ,\"max\",\"min\",\"sum\"], if we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each point (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). project_editor() : When used in Jupyter, it generates a form with a table that allows you to create new projects, delete existing ones and edit the parameters of each project, as shown in the following image.","title":"Simulation functions"},{"location":"user_guide/#projects","text":"Projects contain a set of components defining a case that can be temporarily simulated.","title":"Projects"},{"location":"user_guide/#project-parameters","text":"name [ string ]: Name of the project. description [ string , default = \"Description of the project\"]: Description of the project. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds used for simulation. n_time_steps [ int , default = 8760, min = 1]: Number of time steps to simulate. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial simulation time with format \"DD/MM/YYYY hh:mm:ss\". daylight_saving [ boolean , default = False]: Taking into account daylight saving time in the simulation. If its value is False, the whole simulation is performed in winter time without daylight saving. If True, the daylight saving time change will be taken into account, mainly in the components that define schedules. daylight_saving_start_time [ string , default = \"25/03/2001 02:00:00\"]: daylight saving start time, with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. daylight_saving_end_time [ string , default = \"28/10/2001 02:00:00\"]: daylight saving start time, time with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. n_max_iteration [ int , default = 1000, min = 1]: Maximum number of iterations in each time step. If after this number of iterations the instant has not converged, it is passed to the next time instant. simulation_order [ string-list , default = [ \"Space_type\", \"Exterior_surface\", \"Underground_surface\", \"Interior_surface\", \"Virtual_surface\", \"Shadow_surface\", \"Opening\", \"Space\", \"Building\", \"HVAC_perfect_system\", \"HVAC_DX_system\", \"Calculator\" ]]: Order used for the types of components in the simulation loops. All components not specified are added at the beginning and those defined in this list are added at the end in the established order. Example of project for the simulation of the first week of june with 15 min time step. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project one\") pro.parameter(\"description\").value = \"Project example\" pro.parameter(\"time_step\").value = 60*15 pro.parameter(\"n_time_steps\").value = 24*4*7 pro.parameter(\"initial_time\").value = \"01/06/2001 00:00:00\" Project and component parameters can be changed one by one or in bulk using a dictionary and the set_parameter(dictonary) function, or interactively using the project and component editors. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"Project one\") param = { \"description\": \"Project example\", \"time_step\": 60*15, \"n_time_steps\": 24*4*7, \"initial_time\": \"01/06/2001 00:00:00\" } pro.set_parameters(param)","title":"Project parameters"},{"location":"user_guide/#project-functions","text":"The following is a list of the most useful functions of the Project object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the project. parameter_dict() : Returns a dictonary with all the parameters of the project. set_parameters(dict) : Change project parameters using python dictonary. new_component(type, name) : Creates a new component of the type specified in the first argument and with the name of the second argument. del_component(comp) : Deletes the \"comp\" component. component(name) : Returns the component with name parameter \"name\". Returns \"None\" if not found. component_list() : Returns the list of components of the project. component_dataframe() : Returns pandas DataFrame with the components of the project. read_dict(dict) : Read python dictonary \"dict\" with the parameters of the project and a list of component to create. See Getting started for definition dictonary example. After reading the dictonary check() function is executed. read_json(file) : Read json file to define the project. Json file must have the format used for dictionaries in the read_dic function. After reading the file check() function is executed. write_dict() : Return python dictonary with the definition of the project. The default values of the parameters are written explicitly. write_json(file) : Write json file that define the project. The written json file is exactly the same as the dictionary generated by the \"write_dict\" function. check() : Returns the list of errors after checking all the components. All the errors returned are also printed. simulate(show_percentage = 10) : Perform the time simulation of the project, calculating all the varibles of the components. Once the simulation has started, an informative progress message will be printed every time the percentage set in the show_percentage parameter is exceeded (its default value is 10%), and the average number of iterations performed in each time step, for that percentage, will also be displayed. simulation_dataframe() : Returns pandas DataFrame with information from the latest simulation. For each time step it includes the number of iterations performed and the name of the last component that forced the iteration. dates() : Returns numpy array with the date of each simulation instant, using winter time without daylight saving. component_editor(type) : When used in Jupyter, it generates a form with a table that allows you to create new compenents, delete existing ones and edit the parameters of each component. If the type is specified, a table with only the components of that type will be displayed. If no type is included or type = \u201call\u201d all components will be displayed but only with the common parameters. Following image shows an example of the component editor: the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on.","title":"Project functions"},{"location":"user_guide/#components","text":"Components are objects included in projects that contain parameters and variables. Component list describe the different types of Components in OpenSimula. As an example, we will see how to create three different types of components and how to manage them in our project. this code is a continuation of the definition of the previous project. ... working_day = pro.new_component(\"Day_schedule\",\"working_day\") param = { \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0] } working_day.set_parameters(param) holiday_day = pro.new_component(\"Day_schedule\",\"holiday_day\") param = { \"time_steps\": [], \"values\": [0] } holiday_day.set_parameters(param) week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [], \"weeks_schedules\": [\"week\"] } year.set_parameters(param) To create the components we use project \"new_component\" function. For example, to create a Day_schedule we will use pro.new_component(\"Day_schedule\",\"name\") . Where the first argument is the type of component and the second the name of the component. After creating the components we can modify any of their parameters. After defining a project with its components, changing the parameters one by one or using a dictionary to define it, we can check if there is any error using the check() function and perform the temporary simulation with the simulate() function. ... pro.check() pro.simulate() Python shell output: Checking project: Project 1 ok Simulating Project 1: ... 10%: N_iter: 1.00 20%: N_iter: 1.00 30%: N_iter: 1.00 40%: N_iter: 1.00 50%: N_iter: 1.00 60%: N_iter: 1.00 70%: N_iter: 1.00 80%: N_iter: 1.00 90%: N_iter: 1.00 100%: N_iter: 1.00 Simulation completed. The list of parameters of a project can be obtained in pandas DataFrame format using the project functions parameter_dataframe() . For the components we can get parameters and variables dataframes with parameter_dataframe() and variable_dataframe() . To obtain the list of components in a project with the parameters as columns use the function component_dataframe(comp_type=\"all\") . In the \"type\" argument of the function we can indicate the type of components we want to list (for example: \"Day_schedule\"), or indicate \"all\" (this is the default value), which will show all components including only the three parameters common to all components: \"name\", \"type\" and \"description\". With Jupyter notebooks or Google Collab, writing the python variable of a project the parameter and component dataframe will be shown, and writing one component python variable parameter and variable dataframe will be shown. Next example shows the parameter and component dataframes of our project: ... pro Jupyter shell:","title":"Components"},{"location":"user_guide/#components-functions","text":"The following is a list of the most useful functions of the Components object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the component. set_parameters(dict) : Change component parameters using python dictonary. check() : Returns the list of errors after checking the components. All the errors returned are also printed. variable(name) : Returns the variable \"name\". variable_dataframe(units=False, frequency=None, value=\"mean\", interval=None, pos_neg_columns=[]) : Returns a pandas dataframe with all the variables of the component. This is the meaning of the arguments of the variable_dataframe function. (In bold the default values): units [ False /True]: Include de units in the name of the variable. frequency [ None , \"H\", \"D\", \"M\", \"Y\"]: Frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\"). value [ \"mean\" ,\"max\",\"min\",\"sum\"]: If we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each row (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). interval [ None ,[start_date, end_date]]: List with the start and end dates of the period to be included in the dataframe, if the value is None all values are included. pos_neg_columns [[]]: List of variables that will be included in separate columns positive and negative values, with \"column_name\"_pos and \"column_name\"_neg as names.","title":"Components functions"},{"location":"user_guide/#parameters","text":"Parameters are used to define the characteristics that make up the projects and components. The parameters will be defined as Python dictionary keys (or json format files), that is the format we will use in the examples shown in the documentation. Parameters can be of different types depending on the type of information they contain: Parameter_string: String of characters, e.g.: \"name\": \"Project 1\" . Parameter_boolean: True or False value, e.g.: \"simplified_definition\": False . Parameter_int: Integer value, e.g.: \"time_step\": 3600 . Parameter_float: Floating point value, e.g.: \"conductivity\": 1.8 . Parameter_options: character string included in a closed option list, e.g.: \"file_type\": \"EXCEL\" . Parameter_component: Reference to another component, e.g.: \"meteo_file\": \"Sevilla\" . Parameter_variable: This parameter is used to create a variable in the component by copying it from another component. A new name is defined and the unit will be taken from the original variable. e.g.: \"input_variables\": \"t_1 = meteo.temperature\" , a variable called \"t_1\" will be created which is a copy of the variable \"temperature\" of the component \"meteo\". Parameter_math_exp: parameter defining a mathematical expression. Each of the components knows how to use that mathematical expression within its simulation process. e.g.: \"people_density\": \"0.1 * f\" , this parameter states that the people density shall be calculated by multiplying by 0.1 a variable called \"f\" that the component must include. The mathematical expressions must be written in Python. All of the above types can also be defined as parameter lists, giving rise to the following types: Parameter_string_list: List of String of characters, e.g.: \"authors\": [\"Juan F.\", \"Luis\", \"Ismael\"] . Parameter_boolean_list: List of True or False values, e.g.: \"operated\": [True, True, False] . Parameter_int_list: List of integer values, e.g.: \"people\": [24, 12, 18] . Parameter_float_list: List of floating point values, e.g.: \"solar_alpha\": [0.8, 0.75] . Parameter_options_list: List of character strings included in a closed option list, e.g.: \"day_types\": [\"MONDAY\", \"TUESDAY\"] . Parameter_component_list: List of references to another components, e.g.: \"materials\": [\"Cement mortar\", \"Hollow brick\"] . Parameter_variable_list: List of parameters used to copy a list of variables. e.g.: \"input_variables\": [\"t_1 = meteo.temperature\",\"hr = meteo.relative_humidity\"] . Parameter_math_exp_list: List of mathematical expressions. e.g.: \"curves\": [\"0.3 * t + 20\",\"0.04 * t**2 - 0.2 * t + 3 \"] . The Parameter_component, Parameter_variable, Parameter_component_list and Parameter_variable_list can refer to a component of the same project, in that case it is only necessary to put the name of the component, or a component of another project. In this last case we must write \"project_name->component_name\". e.g. \"meteo_file\": \"Project 1->Sevilla\" . To get or set the value of a parameter we must use the attribute \"value\" of the parameter. If the parameter contain a list we can set/get each value using index, for example: pro.component(\"week\").parameter(\"days_schedules\").value[0] will return \"working_day\" ... pro.component(\"year\").parameter(\"description\").value = \"Example of year schedule\" pro.component(\"year\").parameter(\"description\").value Jupyter output: 'Example of year schedule'","title":"Parameters"},{"location":"user_guide/#variables","text":"Variables are elements included in the components to store the temporal information generated during the simulation. Variables are lists of floating values, one for each instant of simulated time. To access the values of a variable we use the values attribute which returns a numpy.array object (NumPy library array object). ... pro.component(\"year\").variable(\"values\").values Jupyter output: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ... 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Output is truncated. View as a scrollable element or open in a text editor. Adjust cell output settings... The variable_dataframe(units, frequency, value, interval, pos_neg_columns) method of the components returns a pandas dataframe with all the variables of the component. As an example we can see how to obtain the monthly average values of the variables of a meteorological file (File_met component): ... pro.component(\"met_file\").variable_dataframe(frequency=\"M\",value=\"mean\") Jupyter shell:","title":"Variables"}]}