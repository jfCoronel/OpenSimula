{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This site contains the documentation for the OpenSimula project. Github site OpenSimula is a component-based time simulation environment in Python. The main objective is the thermal and energy simulation of different systems and installations, mainly in buildings, although it can be used to simulate any component that presents a temporal variation. Structure The general object structure provided by OpenSimula is composed of three main elements: Simulation: The global environment for simulation. Project: A set of components that define a problem that can be temporarily simulated. Component: These are the base elements on which the simulation is performed. The types of components currently available can be consulted in section Component list . Parameters Parameters are used to define the characteristics that make up the projects and components. Parameters can be of different types depending on the type of information they contain (strings, boolean, integer, float, options, ...). A list of all parameter types and their possibilities can be found in the User guide . : Variables Variables are elements included in the components to store the temporal information generated during the simulation. Documentation Getting started User guide Component list Developer guide Release notes This is the list of changes to OpenSimula between each release. For full details, see the commit logs. Version 0.2 0.2.0 (January 1, 2025): First implementation for the building definition components and the HVAC_perfect_system \u00a9 JFC 2024","title":"Home"},{"location":"#structure","text":"The general object structure provided by OpenSimula is composed of three main elements: Simulation: The global environment for simulation. Project: A set of components that define a problem that can be temporarily simulated. Component: These are the base elements on which the simulation is performed. The types of components currently available can be consulted in section Component list .","title":"Structure"},{"location":"#parameters","text":"Parameters are used to define the characteristics that make up the projects and components. Parameters can be of different types depending on the type of information they contain (strings, boolean, integer, float, options, ...). A list of all parameter types and their possibilities can be found in the User guide . :","title":"Parameters"},{"location":"#variables","text":"Variables are elements included in the components to store the temporal information generated during the simulation.","title":"Variables"},{"location":"#documentation","text":"Getting started User guide Component list Developer guide","title":"Documentation"},{"location":"#release-notes","text":"This is the list of changes to OpenSimula between each release. For full details, see the commit logs. Version 0.2 0.2.0 (January 1, 2025): First implementation for the building definition components and the HVAC_perfect_system \u00a9 JFC 2024","title":"Release notes"},{"location":"component_list/","text":"Component List Common parameters All the components include these three parameters: name [ string ]: Name of the component. type [ string ]: Type of the component. description [ string ]: Description of the component. We have divided the list of all components into several groups of related components: Components to define shedules : Day_schedule, Week_schedule, Year_schedule. Components for reading files : File_met, File_data. Constructive components : Material, Construction, Glazing, Frame, Opening_type. Building definition components : Building, Space_type, Space, Exterior_surface, Interior_surface, Underground_surface, Virtual_surface, Opening, Shadow_surface. HVAC systems components : HVAC_perfect_system. Components for various utilities : Calculator.","title":"Component list"},{"location":"component_list/#component-list","text":"","title":"Component List"},{"location":"component_list/#common-parameters","text":"All the components include these three parameters: name [ string ]: Name of the component. type [ string ]: Type of the component. description [ string ]: Description of the component. We have divided the list of all components into several groups of related components: Components to define shedules : Day_schedule, Week_schedule, Year_schedule. Components for reading files : File_met, File_data. Constructive components : Material, Construction, Glazing, Frame, Opening_type. Building definition components : Building, Space_type, Space, Exterior_surface, Interior_surface, Underground_surface, Virtual_surface, Opening, Shadow_surface. HVAC systems components : HVAC_perfect_system. Components for various utilities : Calculator.","title":"Common parameters"},{"location":"component_list_HVAC_systems/","text":"Component List for HVAC system definition HVAC_perfect_system Component for the perfect conditioning of a space. With this component we can obtain the heating and cooling loads (sensible and latent). Parameters file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be controlled by this system. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. outdoor_air_flow [ math_exp , unit = \"m\u00b3/s\", default = \"0\"]: Outside air flow rate (ventilation) supplied to the space. This flow rate is only entered if the system is in operation. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. humidifying_setpoint [ math_exp , unit = \"%\", default = \"0\"]: Space relative humidity setpoint for humidification. If the relative humidity of the space is below this value, latent heat is added to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. dehumidifying_setpoint [ math_exp , unit = \"%\", default = \"100\"]: Space relative humidity setpoint for dehumidification. If the relative humidity of the space is higher this value, latent heat is removed to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. If outside air (ventilation) is present, it is introduced into the space as \u2018uncontrolled system heat\u2019, and the load values associated with the ventilation can be viewed in the space. The load supplied by the system is that required to maintain the space within the specified temperature and humidity set points, including ventilation if present. Example: ... system = osm.components.HVAC_perfect_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"outdoor_air_flow\": \"0.1\", \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"humidifying_setpoint\": \"30\", \"dehumidifying_setpoint\": \"70\", \"input_variables\":[\"f = HVAC_schedule.values\"], \"system_on_off\": \"f\" } system.set_parameters(param) Variables After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system. Q_latent [W]: Latent heat supplied by the system. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. humififying_setpoint [%]: Low relative humidity setpoint. dehumidifying_setpoint [%]: High relative humidity setpoint. system_on_off [on/off]: Operation of the system, on (1), off (0).","title":"component list HVAC systems"},{"location":"component_list_HVAC_systems/#component-list-for-hvac-system-definition","text":"","title":"Component List for HVAC system definition"},{"location":"component_list_HVAC_systems/#hvac_perfect_system","text":"Component for the perfect conditioning of a space. With this component we can obtain the heating and cooling loads (sensible and latent).","title":"HVAC_perfect_system"},{"location":"component_list_HVAC_systems/#parameters","text":"file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to be controlled by this system. input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. outdoor_air_flow [ math_exp , unit = \"m\u00b3/s\", default = \"0\"]: Outside air flow rate (ventilation) supplied to the space. This flow rate is only entered if the system is in operation. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. heating_setpoint [ math_exp , unit = \"\u00b0C\", default = \"20\"]: Space heating setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. cooling_setpoint [ math_exp , unit = \"\u00b0C\", default = \"25\"]: Space Cooling setpoint temperature. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. humidifying_setpoint [ math_exp , unit = \"%\", default = \"0\"]: Space relative humidity setpoint for humidification. If the relative humidity of the space is below this value, latent heat is added to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. dehumidifying_setpoint [ math_exp , unit = \"%\", default = \"100\"]: Space relative humidity setpoint for dehumidification. If the relative humidity of the space is higher this value, latent heat is removed to maintain the relative humidity. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. sytem_on_off [ math_exp , unit = \"on/off\", default = \"1\"]: If this value is 0, the system will be off, otherwise it will be on. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. If outside air (ventilation) is present, it is introduced into the space as \u2018uncontrolled system heat\u2019, and the load values associated with the ventilation can be viewed in the space. The load supplied by the system is that required to maintain the space within the specified temperature and humidity set points, including ventilation if present. Example: ... system = osm.components.HVAC_perfect_system(\"system\",project) param = { \"space\": \"space_1\", \"file_met\": \"Denver\", \"outdoor_air_flow\": \"0.1\", \"heating_setpoint\": \"20\", \"cooling_setpoint\": \"27\", \"humidifying_setpoint\": \"30\", \"dehumidifying_setpoint\": \"70\", \"input_variables\":[\"f = HVAC_schedule.values\"], \"system_on_off\": \"f\" } system.set_parameters(param)","title":"Parameters"},{"location":"component_list_HVAC_systems/#variables","text":"After the simulation we will have the following variables of this component: Q_sensible [W]: Sensible heat supplied by the system. Q_latent [W]: Latent heat supplied by the system. outdoor_air_flow [m\u00b3/s]: Outside air flow rate (ventilation) supplied to the space. heating_setpoint [\u00b0C]: Heating setpoint temperature. cooling_setpoint [\u00b0C]: Cooling setpoint temperature. humififying_setpoint [%]: Low relative humidity setpoint. dehumidifying_setpoint [%]: High relative humidity setpoint. system_on_off [on/off]: Operation of the system, on (1), off (0).","title":"Variables"},{"location":"component_list_building/","text":"Component List for building definition elements Building Base component for the definition of a building. The building is made up of a set of spaces (Space component). Parameters file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the east (Global x-axis). The coordinates of all building elements refer to the building coordinate system. albedo [ float , unit = \"frac\", default = 0.3, min = 0, max = 1]: Solar reflectivity of the ground surrounding the building. Used to calculate the solar radiation reflected to the exterior surfaces of the building. initial_temperature [ float , unit = \"\u00b0C\", default = 20]: Initial temperature of all building components at the beginning of the simulation. initial_humidity [ float , unit = \"g/kg\", default = 7.3]: Initial absolute humidity of all building spaces at the beginning of the simulation. shadow_calculation [ option , default = \"INSTANT\", options = [\"NO\",\"INSTANT\",\"INTERPOLATION\"]]: Procedure used for the exterior calculation of the shadows produced by the shading surfaces \"Shadow_surface\" and the building itself. \u201cNO\": no shadows are calculated, \"INSTANT\": Shadows are calculated for each instant of simulated time. \"INTERPOLATION\": The shadows are calculated for 36 x 18 = 648 fixed solar positions and then the shadows for every time step are obtained by interpolating on these tables. The following figure shows the building's coordinate system: Example: ... building = osm.components.Building(\"building\",project) param = { \"file_met\": \"met\" \"azimuth\": 90, \"albedo\": 0.4 } building.set_parameters(param) functions The Building component include the following functions: show3D(hide, opacity, coordinate_system, space) : Displays in Jupyter an interactive 3D visualization of the building (using pyVista). hide : (default value: []) List of the types of components that we do not want to show, for example [\u201cInterior_surface\u201d, \"Underground_surface\"] will hide these two types of components. opacity : Opacity of the surfaces, 1 (default value) for totally opaque and 0 for totally transparent. coordinate_system : Coordinate system in which the building will be displayed, \u201cglobal\u201d (default value), \u201clocal\u201d the coordinate system of the building. space : (default value: \u201call\u201d) If a space name is specified, the rest of the spaces will be shown dimmed (opacity = 0.25). show3D_shadows(date) : Calculates and displays an interactive 3D visualization of the building with the shadows occurring for the date specified. date : Python datetime object specifying a specific date. See next figure as example. Space_type Component used to define the type of space. This component will be referenced by all spaces that are of the same type. This component defines the internal loads and some of the functional characteristics of the space. Parameters input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. people_density [ math_exp , unit = \"p/m\u00b2\", default = \"0.1\"]: Occupancy density, defined in persons per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below people_sensible [ float , unit = \"W/p\", default = 70, min = 0]: Sensible heat generated by each of the occupants of the space. people_latent [ float , unit = \"W/p\", default = 35, min = 0]: Latent heat generated by each of the occupants of the space. people_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Long wave radiant fraction of heat generated by occupants. The rest of the heat is assumed to be convective. light_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Lighting density, defined as the electrical lighting power [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. light_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Short wave radiant fraction of heat generated by lights. The rest of the heat is assumed to be convective. other_gains_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Other gains density, defined as the heat generated by other gains (Household appliances, office automation, miscellaneous electrical equipment, etc.) [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. other_gains_radiant_fraction [ float , unit = \"frac\", default = 0.5, min = 0, max = 1]: Long wave radiant fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. other_gains_latent_fraction [ float , unit = \"frac\", default = 0.0, min = 0, max = 1]: Latent fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. infiltration [ math_exp , unit = \"1/h\", default = \"1\"]: Air flow rate infiltrated into the space from outside and expressed in volumes of the space per hour. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. Assuming that the variation of occupancy, lighting and other loads has been defined in a \"Year_schedule\" component, named \"schedule\" with values between 0 and 1, the following example would capture that variation. Example: ... office_space = osm.components.Space_type(\"office_space\",project) param = { \"input_variables\": [\"f = schedule.values\"] \"people_density\": \"0.1*f\", \"light_density\": \"10*f\", \"other_gains_density\": \"4.2*f\", \"other_gains_radiant_fraction\": 0.6, \"infiltration\": \"0.5\" } office_space.set_parameters(param) Variables After the simulation we will have the following variables of this component: people_convective [W/m\u00b2]: Convective heat due to occupancy. people_radiant [W/m\u00b2]: Radiant heat (long wave) due to occupancy. people_latent [W/m\u00b2]: Latent heat due to occupancy. light_convective [W/m\u00b2]: Convective heat due to lighting. light_radiant [W/m\u00b2]: Radiant heat (short wave) due to lighting. other_gains_convective [W/m\u00b2]: Convective heat due to other gains. other_gains_radiant [W/m\u00b2]: Radiant heat (long wave) due to other gains. other_gains_latent [W/m\u00b2]: Latent heat due to other gains. infiltration_rate [1/h]: Air flow rate infiltrated into the space from outside, expressed in volumes of the space per hour. Space Component used to define each of the building's spaces. The spaces of a building are each of the volumes of the building where we can find a different temperatures. The spaces will be referenced by the different surfaces that comprise them. Parameters building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. space_type [ component , default = \"not_defined\", component type = Space_type]: Reference to the \"Space_type\" component that defines its occupational and functional characteristics. floor_area [ float , unit = \"m\u00b2\", default = 1, min = 0]: Floor area of the space. volume [ float , unit = \"m\u00b3\", default = 1, min = 0]: Volume of the space. furniture_weight [ float , unit = \"kg/m\u00b2\", default = 10, min = 0]: Weight of the furniture in the space. Used to increase the thermal inertia of the space which will be added to that of the air (for the furniture a specific heat of 1000 J/kg\u00b7K will be used). Example: ... space_1 = osm.components.Space(\"space_1\",project) param = { \"building\": \"building\", \"space_type\": \"office_space\", \"floor_area\": 30, \"volume\": 90 } space_1.set_parameters(param) Variables After the simulation we will have the following variables of this component: temperatura [\u00b0C]: Space dry air temperatura. abs_humidity [g/kg]: Absolute space air humidity. rel_humidity [%]: Relative space air humidity. people_convective [W]: Convective heat due to occupancy. people_radiant [W]: Radiant heat (long wave) due to occupancy. people_latent [W]: Latent heat due to occupancy. light_convective [W]: Convective heat due to lighting. light_radiant [W]: Radiant heat (short wave) due to lighting. other_gains_convective [W]: Convective heat due to other gains. other_gains_radiant [W]: Radiant heat (long wave) due to other gains. other_gains_latent [W]: Latent heat due to other gains. solar_direct_gains [W]: Direct solar radiation gains. infiltration_flow [m\u00b3/s]: Air flow rate infiltrated into the space from outside. infiltration_sensible_heat [W]: Sensible heat due to air infiltration from outdoor. surfaces_convective [W]: Convective heat flux exchanged between interior surfaces and space air. delta_int_energy [W]: Increase of internal energy of the space (air and furniture). u_system_sensible_heat [W]: Sensible heat introduced by uncontrolled systems in space. Spaces can collect airflows from various types of systems, those that are not capable of controlling the room temperature are called \u2018uncontrolled systems\u2019. For example, a flow of outside air, a flow from a dedicated outdoor air system, etc. u_system_sensible_latent [W]: Latent heat introduced by uncontrolled systems in space. system_sensible_heat [W]: Sensible heat introduced by the system responsible for space control. Positive for heating and negative for cooling. system_sensible_latent [W]: Latent heat introduced by control system in space. Positive for humidification and negative for dehumidification. Exterior_surface Component to define the exterior surfaces of the building: vertical or inclined walls and horizontal or inclined roofs. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figures show the surface coordinate system versus the building coordinate system for rectangular or polygonal surfaces. Example: ... north_wall = osm.components.Exterior_surface(\"north_wall\",project) param = { \"ref_point\": [8,0,-6], \"width\": 8, \"height\": 2.7, \"azimuth\": 180, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"space\": \"space_1\" } north_wall.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface. Interior_surface Component to define the interior surfaces of the building: vertical or inclined interior walls and slabs between floors. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [2,2], min = 0]: Convective film coefficients of the 0 an 1 side, respectively. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_wall = osm.components.Interior_surface(\"interior_wall\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"spaces\": [\"space_0\", \"space_1\"] } interior_wall.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer \"0\" surface and those ending in 1 to the \"1\" surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. Underground_surface Component define the surfaces in contact with the ground. Floors or vertical undergorund enclosures. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float , unit = \"W/m\u00b2K\", default = 2, min = 0]: Convective film coefficient of interior surface. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... floor = osm.components.Underground_surface(\"floor\",project) param = { \"shape\": \"POLYGON\", \"ref_point\": [0,0,0], \"x_polygon\": [0,8,8,0], \"y_polygon\": [0,0,6,6], \"azimuth\": 0, \"altitude\": -90, \"construction\": \"Multilayer wall\", \"space\": \"space_1\" } floor.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the underground surface and those ending in 1 to the interior surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv1 [W/m\u00b2]: Convective heat flux at the ineterior surface. q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the interior surface due to internal gains. q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due to internal gains. q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. Virtual_surface Virtual surfaces are used to define gaps between two spaces. Spaces in OpenSimula must be completely enclosed by surfaces for the radiant exchange calculation to work correctly. Parameters shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_hole = osm.components.Virtual_surface(\"interior_hole\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"spaces\": [\"space_0\",\"space_1\"] } interior_hole.set_parameters(param) Opening Component for defining openings in exterior surfaces, e.g. windows or doors. These elements must be rectangular. Parameters surface [ component , default = \"not_defined\", component type = Exterior_surface]: Reference to the \"Exterior_surface\" in which it is located. width [ float , unit = \"m\", default = 1, min = 0]: Width of the opening. height [ float , unit = \"m\", default = 1, min = 0]: Height of the opening. ref_point [ float-list , unit = \"m\", default = [0,0]]: Two-dimensional coordinate of the opening reference point in the exterior wall coordinate system. The reference point is the lower left corner of the opening viewed from the outside. opening_type [ component , default = \"not_defined\", component type = Opening_type]: Reference to the \"Opening_type\" component that defines its composition. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figure show geometrical definition of the opening in the surface coordinate system. Example: ... south_window = osm.components.Opening(\"south_window\",project) param = { \"surface\": \"south_wall\" \"ref_point\": [2,1], \"width\": 3, \"height\": 1.3, \"opening_type\": \"double_glazed_window\" } south_window.set_parameters(param) Variables After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd [W/m\u00b2]: Conductive heat flux. q_sol_dir_trans [W/m\u00b2]: Direct solar radiation passing through into space. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_sol01, q_sol10 [W/m\u00b2]: Solar heat flux appearing on surface \"i\" due to the absorption of solar radiation on surface \"j\". q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface. Shadow_surface Component for defining shading surfaces external to the building. Parameters building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. Example: ... overhang = osm.components.Shadow_surface(\"overhang\") param = { \"building\": \"Building\", \"ref_point\": [0,-1,2.7], \"width\": 8, \"height\": 1, \"azimuth\": 0, \"altitude\": 90 }, overhang.set_parameters(param)","title":"Component list building"},{"location":"component_list_building/#component-list-for-building-definition-elements","text":"","title":"Component List for building definition elements"},{"location":"component_list_building/#building","text":"Base component for the definition of a building. The building is made up of a set of spaces (Space component).","title":"Building"},{"location":"component_list_building/#parameters","text":"file_met [ component , default = \"not_defined\", component type = File_met]: Reference to the component where the weather file is defined. azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the east (Global x-axis). The coordinates of all building elements refer to the building coordinate system. albedo [ float , unit = \"frac\", default = 0.3, min = 0, max = 1]: Solar reflectivity of the ground surrounding the building. Used to calculate the solar radiation reflected to the exterior surfaces of the building. initial_temperature [ float , unit = \"\u00b0C\", default = 20]: Initial temperature of all building components at the beginning of the simulation. initial_humidity [ float , unit = \"g/kg\", default = 7.3]: Initial absolute humidity of all building spaces at the beginning of the simulation. shadow_calculation [ option , default = \"INSTANT\", options = [\"NO\",\"INSTANT\",\"INTERPOLATION\"]]: Procedure used for the exterior calculation of the shadows produced by the shading surfaces \"Shadow_surface\" and the building itself. \u201cNO\": no shadows are calculated, \"INSTANT\": Shadows are calculated for each instant of simulated time. \"INTERPOLATION\": The shadows are calculated for 36 x 18 = 648 fixed solar positions and then the shadows for every time step are obtained by interpolating on these tables. The following figure shows the building's coordinate system: Example: ... building = osm.components.Building(\"building\",project) param = { \"file_met\": \"met\" \"azimuth\": 90, \"albedo\": 0.4 } building.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#functions","text":"The Building component include the following functions: show3D(hide, opacity, coordinate_system, space) : Displays in Jupyter an interactive 3D visualization of the building (using pyVista). hide : (default value: []) List of the types of components that we do not want to show, for example [\u201cInterior_surface\u201d, \"Underground_surface\"] will hide these two types of components. opacity : Opacity of the surfaces, 1 (default value) for totally opaque and 0 for totally transparent. coordinate_system : Coordinate system in which the building will be displayed, \u201cglobal\u201d (default value), \u201clocal\u201d the coordinate system of the building. space : (default value: \u201call\u201d) If a space name is specified, the rest of the spaces will be shown dimmed (opacity = 0.25). show3D_shadows(date) : Calculates and displays an interactive 3D visualization of the building with the shadows occurring for the date specified. date : Python datetime object specifying a specific date. See next figure as example.","title":"functions"},{"location":"component_list_building/#space_type","text":"Component used to define the type of space. This component will be referenced by all spaces that are of the same type. This component defines the internal loads and some of the functional characteristics of the space.","title":"Space_type"},{"location":"component_list_building/#parameters_1","text":"input_variables [ variable_list , default = []]: List of variables from other components used in this component. They may be used in parameters of the type math_exp. people_density [ math_exp , unit = \"p/m\u00b2\", default = \"0.1\"]: Occupancy density, defined in persons per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below people_sensible [ float , unit = \"W/p\", default = 70, min = 0]: Sensible heat generated by each of the occupants of the space. people_latent [ float , unit = \"W/p\", default = 35, min = 0]: Latent heat generated by each of the occupants of the space. people_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Long wave radiant fraction of heat generated by occupants. The rest of the heat is assumed to be convective. light_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Lighting density, defined as the electrical lighting power [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. light_radiant_fraction [ float , unit = \"frac\", default = 0.6, min = 0, max = 1]: Short wave radiant fraction of heat generated by lights. The rest of the heat is assumed to be convective. other_gains_density [ math_exp , unit = \"W/m\u00b2\", default = \"10\"]: Other gains density, defined as the heat generated by other gains (Household appliances, office automation, miscellaneous electrical equipment, etc.) [W] per m\u00b2 of floor. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. See example below. other_gains_radiant_fraction [ float , unit = \"frac\", default = 0.5, min = 0, max = 1]: Long wave radiant fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. other_gains_latent_fraction [ float , unit = \"frac\", default = 0.0, min = 0, max = 1]: Latent fraction of the heat generated by other gains. The convective fraction is calculated by subtracting the radiant and latent fractions. infiltration [ math_exp , unit = \"1/h\", default = \"1\"]: Air flow rate infiltrated into the space from outside and expressed in volumes of the space per hour. The mathematical expression may contain any of the variables declared in the \"input_variables\" parameter, to be able to reflect the time variation of this value. Assuming that the variation of occupancy, lighting and other loads has been defined in a \"Year_schedule\" component, named \"schedule\" with values between 0 and 1, the following example would capture that variation. Example: ... office_space = osm.components.Space_type(\"office_space\",project) param = { \"input_variables\": [\"f = schedule.values\"] \"people_density\": \"0.1*f\", \"light_density\": \"10*f\", \"other_gains_density\": \"4.2*f\", \"other_gains_radiant_fraction\": 0.6, \"infiltration\": \"0.5\" } office_space.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables","text":"After the simulation we will have the following variables of this component: people_convective [W/m\u00b2]: Convective heat due to occupancy. people_radiant [W/m\u00b2]: Radiant heat (long wave) due to occupancy. people_latent [W/m\u00b2]: Latent heat due to occupancy. light_convective [W/m\u00b2]: Convective heat due to lighting. light_radiant [W/m\u00b2]: Radiant heat (short wave) due to lighting. other_gains_convective [W/m\u00b2]: Convective heat due to other gains. other_gains_radiant [W/m\u00b2]: Radiant heat (long wave) due to other gains. other_gains_latent [W/m\u00b2]: Latent heat due to other gains. infiltration_rate [1/h]: Air flow rate infiltrated into the space from outside, expressed in volumes of the space per hour.","title":"Variables"},{"location":"component_list_building/#space","text":"Component used to define each of the building's spaces. The spaces of a building are each of the volumes of the building where we can find a different temperatures. The spaces will be referenced by the different surfaces that comprise them.","title":"Space"},{"location":"component_list_building/#parameters_2","text":"building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. space_type [ component , default = \"not_defined\", component type = Space_type]: Reference to the \"Space_type\" component that defines its occupational and functional characteristics. floor_area [ float , unit = \"m\u00b2\", default = 1, min = 0]: Floor area of the space. volume [ float , unit = \"m\u00b3\", default = 1, min = 0]: Volume of the space. furniture_weight [ float , unit = \"kg/m\u00b2\", default = 10, min = 0]: Weight of the furniture in the space. Used to increase the thermal inertia of the space which will be added to that of the air (for the furniture a specific heat of 1000 J/kg\u00b7K will be used). Example: ... space_1 = osm.components.Space(\"space_1\",project) param = { \"building\": \"building\", \"space_type\": \"office_space\", \"floor_area\": 30, \"volume\": 90 } space_1.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_1","text":"After the simulation we will have the following variables of this component: temperatura [\u00b0C]: Space dry air temperatura. abs_humidity [g/kg]: Absolute space air humidity. rel_humidity [%]: Relative space air humidity. people_convective [W]: Convective heat due to occupancy. people_radiant [W]: Radiant heat (long wave) due to occupancy. people_latent [W]: Latent heat due to occupancy. light_convective [W]: Convective heat due to lighting. light_radiant [W]: Radiant heat (short wave) due to lighting. other_gains_convective [W]: Convective heat due to other gains. other_gains_radiant [W]: Radiant heat (long wave) due to other gains. other_gains_latent [W]: Latent heat due to other gains. solar_direct_gains [W]: Direct solar radiation gains. infiltration_flow [m\u00b3/s]: Air flow rate infiltrated into the space from outside. infiltration_sensible_heat [W]: Sensible heat due to air infiltration from outdoor. surfaces_convective [W]: Convective heat flux exchanged between interior surfaces and space air. delta_int_energy [W]: Increase of internal energy of the space (air and furniture). u_system_sensible_heat [W]: Sensible heat introduced by uncontrolled systems in space. Spaces can collect airflows from various types of systems, those that are not capable of controlling the room temperature are called \u2018uncontrolled systems\u2019. For example, a flow of outside air, a flow from a dedicated outdoor air system, etc. u_system_sensible_latent [W]: Latent heat introduced by uncontrolled systems in space. system_sensible_heat [W]: Sensible heat introduced by the system responsible for space control. Positive for heating and negative for cooling. system_sensible_latent [W]: Latent heat introduced by control system in space. Positive for humidification and negative for dehumidification.","title":"Variables"},{"location":"component_list_building/#exterior_surface","text":"Component to define the exterior surfaces of the building: vertical or inclined walls and horizontal or inclined roofs.","title":"Exterior_surface"},{"location":"component_list_building/#parameters_3","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figures show the surface coordinate system versus the building coordinate system for rectangular or polygonal surfaces. Example: ... north_wall = osm.components.Exterior_surface(\"north_wall\",project) param = { \"ref_point\": [8,0,-6], \"width\": 8, \"height\": 2.7, \"azimuth\": 180, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"space\": \"space_1\" } north_wall.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_2","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface.","title":"Variables"},{"location":"component_list_building/#interior_surface","text":"Component to define the interior surfaces of the building: vertical or inclined interior walls and slabs between floors.","title":"Interior_surface"},{"location":"component_list_building/#parameters_4","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [2,2], min = 0]: Convective film coefficients of the 0 an 1 side, respectively. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_wall = osm.components.Interior_surface(\"interior_wall\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"construction\": \"Multilayer_wall\", \"spaces\": [\"space_0\", \"space_1\"] } interior_wall.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_3","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer \"0\" surface and those ending in 1 to the \"1\" surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps.","title":"Variables"},{"location":"component_list_building/#underground_surface","text":"Component define the surfaces in contact with the ground. Floors or vertical undergorund enclosures.","title":"Underground_surface"},{"location":"component_list_building/#parameters_5","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed the \"0\" side, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. construction [ component , default = \"not_defined\", component type = Construction]: Reference to the \"Construction\" component that defines its composition. space [ component , default = \"not_defined\", component type = Space]: Reference to the \"Space\" component to which it belongs. h_cv [ float , unit = \"W/m\u00b2K\", default = 2, min = 0]: Convective film coefficient of interior surface. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... floor = osm.components.Underground_surface(\"floor\",project) param = { \"shape\": \"POLYGON\", \"ref_point\": [0,0,0], \"x_polygon\": [0,8,8,0], \"y_polygon\": [0,0,6,6], \"azimuth\": 0, \"altitude\": -90, \"construction\": \"Multilayer wall\", \"space\": \"space_1\" } floor.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_4","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the underground surface and those ending in 1 to the interior surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd0, q_cd1 [W/m\u00b2]: Conductive heat flux at the surfaces. q_cv1 [W/m\u00b2]: Convective heat flux at the ineterior surface. q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the interior surface due to internal gains. q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due to internal gains. q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the interior surface due other surfaces temperatures. p_0, p_1 [W/m\u00b2]: Conductive heat flux at the surfaces due to previous time steps.","title":"Variables"},{"location":"component_list_building/#virtual_surface","text":"Virtual surfaces are used to define gaps between two spaces. Spaces in OpenSimula must be completely enclosed by surfaces for the radiant exchange calculation to work correctly.","title":"Virtual_surface"},{"location":"component_list_building/#parameters_6","text":"shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. spaces [ component-list , default = [\"not_defined\",\"not_defined], component type = Space]: Reference to the \"Space\" components for the side 0 and the side 1. See figures of the coordinate systems in the \"Exterior_surface\" component. Example: ... interior_hole = osm.components.Virtual_surface(\"interior_hole\",project) param = { \"ref_point\": [8,0,-3], \"width\": 8, \"height\": 2.7, \"azimuth\": 0, \"altitude\": 0, \"spaces\": [\"space_0\",\"space_1\"] } interior_hole.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#opening","text":"Component for defining openings in exterior surfaces, e.g. windows or doors. These elements must be rectangular.","title":"Opening"},{"location":"component_list_building/#parameters_7","text":"surface [ component , default = \"not_defined\", component type = Exterior_surface]: Reference to the \"Exterior_surface\" in which it is located. width [ float , unit = \"m\", default = 1, min = 0]: Width of the opening. height [ float , unit = \"m\", default = 1, min = 0]: Height of the opening. ref_point [ float-list , unit = \"m\", default = [0,0]]: Two-dimensional coordinate of the opening reference point in the exterior wall coordinate system. The reference point is the lower left corner of the opening viewed from the outside. opening_type [ component , default = \"not_defined\", component type = Opening_type]: Reference to the \"Opening_type\" component that defines its composition. h_cv [ float-list , unit = \"W/m\u00b2K\", default = [19.3,2], min = 0]: Convective film coefficients of the exterior and interior surfaces, respectively. The following figure show geometrical definition of the opening in the surface coordinate system. Example: ... south_window = osm.components.Opening(\"south_window\",project) param = { \"surface\": \"south_wall\" \"ref_point\": [2,1], \"width\": 3, \"height\": 1.3, \"opening_type\": \"double_glazed_window\" } south_window.set_parameters(param)","title":"Parameters"},{"location":"component_list_building/#variables_5","text":"After the simulation we will have the following variables of this component, all variables ending in 0 refer to the outer surface and those ending in 1 to the inner surface: T_s0, T_s1 [\u00b0C]: Surface temperatures q_cd [W/m\u00b2]: Conductive heat flux. q_sol_dir_trans [W/m\u00b2]: Direct solar radiation passing through into space. q_cv0, q_cv1 [W/m\u00b2]: Convective heat flux at the surfaces. q_sol0, q_sol1 [W/m\u00b2]: Solar heat flux at the surfaces. q_sol01, q_sol10 [W/m\u00b2]: Solar heat flux appearing on surface \"i\" due to the absorption of solar radiation on surface \"j\". q_swig0, q_swig1 [W/m\u00b2]: Radiant short wave heat flux at the surfaces due to internal gains. q_lwig0, q_lwig1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due to internal gains. q_lwt0, q_lwt1 [W/m\u00b2]: Radiant long wave heat flux at the surfaces due other surfaces temperatures. T_rm [\u00b0C]: Exterior radiant mean temperature. E_dir [W/m\u00b2]: Direct solar radiation incident on the exterior surface. E_dif [W/m\u00b2]: Diffuse solar radiation incident on the exterior surface.","title":"Variables"},{"location":"component_list_building/#shadow_surface","text":"Component for defining shading surfaces external to the building.","title":"Shadow_surface"},{"location":"component_list_building/#parameters_8","text":"building [ component , default = \"not_defined\", component type = Building]: Reference to the \"Building\" component of which it is a part. shape [ option , default = \"RECTANGLE\", options = [\"RECTANGLE\",\"POLYGON\"]]: Shape of the surface, for a rectangle the parameters \"width\" and \"height\" will be used and for a polygon the parameters \"x-polygon\" and \"y-polygon\". width [ float , unit = \"m\", default = 1, min = 0]: Width of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". height [ float , unit = \"m\", default = 1, min = 0]: Height of the rectangular surface. Only used if \"shape\" is equal to \"RECTANGLE\". ref_point [ float-list , unit = \"m\", default = [0,0,0]]: Three-dimensional coordinate of the surface reference point. For rectangular surfaces the lower left corner of the surface viewed from the outside, for surfaces defined by polygons the three-dimensional location of the coordinate origin used to define the polygon in two dimensions. x_polygon [ float-list , unit = \"m\", default = [0,10,10,0]]: List with the x-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". y_polygon [ float-list , unit = \"m\", default = [0,0,10,10]]: List with the y-coordinates of the points defining the surface polygon. Only used if \"shape\" is equal to \"POLYGON\". azimuth [ float , unit = \"\u00b0\", default = 0, min = -180, max = 180]: Angle formed between the x-axis of the building and the projection of the x-axis of the surface. altitude [ float , unit = \"\u00b0\", default = 0, min = -90, max = 90]: Angle formed between the z-axis of the building and the y-axis of the surface. Example: ... overhang = osm.components.Shadow_surface(\"overhang\") param = { \"building\": \"Building\", \"ref_point\": [0,-1,2.7], \"width\": 8, \"height\": 1, \"azimuth\": 0, \"altitude\": 90 }, overhang.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/","text":"Component List for constructive elements Material Component to describe the thermal characteristics of the materials used in the enclosures (Construction component). Parameters conductivity [ float , unit = \"W/(n\u00b7K)\", default = 1, min = 0]: Material thermal conductivity. density [ float , unit = \"kg/m\u00b3\", default = 1000, min = 0.001]: Material Density. specific_heat [ float , unit = \"J/(kg\u00b7K)\", default = 1000, min = 0.001]: Material specific heat. use_resistance [ boolean , default = False]: If the value is \"False\", conductivity, density and specific heat will be used. For \"True\" value, thermal resistance, density and specific heat will be used. thermal_resistance [ float , unit = \"(m\u00b2\u00b7K)/W\", default = 1, min = 0]: Thermal resistance of material layer. Example: ... material = pro.new_component(\"Material\",\"concrete\") param = { \"conductivity\": 1.95, \"density\": 2240, \"specific_heat\": 900, } material.set_parameters(param) Construction Component to describe the composition of the different layers (Material component) of an enclosure. Parameters solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity for surfaces 1 and 2. materials [[ component-list , default = [], component type = Material]]: Materials list for each of the layers, defined from surface 1 to 2. thicknesses [ float-list , unit = \"m\", default = [], min = 0]: Thicknesses of each of the layers defined in the \"materials\" parameter. Must have the same number of elements as the \"materials\" parameter. Example: ... construction = pro.new_component(\"Construction\",\"Multilayer wall\") param = { \"solar_alpha\": [0.8, 0.8], \"materials\": [\"Gypsum board\",\"EPS board\",\"Heavyweight concrete\",\"EPS board\",\"Stucco\"], \"thicknesses\": [0.016, 0.076, 0.203, 0.076, 0.025], } construction.set_parameters(param) Glazing Component to describe the glazings. Default values are those of a clear single pane of 6 mm thickness. Parameters solar_tau [ float , unit = \"frac\", default = 0.849, min = 0, max = 1]: Solar transmittance of glass at normal incidence. solar_rho [ float-list , unit = \"frac\", default = [0.077,0.077], min = 0, max = 1]: Solar reflectance of glass at normal incidence, for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.837,0.837], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. g [ float-list , unit = \"frac\", default = [0.867093,0.867093], min = 0, max = 1]: Solar factor at normal incidence, calculated according to EN 410:2011, for surfaces 1 and 2. U [ float , unit = \"W/m\u00b2K\", default = 5.686, min = 0]: Thermal transmittance of glazing calculated according to EN 673:2011. f_tau_nor [[ math-exp , default = \"1.3186 * cos_theta^3 - 3.5251 * cos_theta^2 + 3.2065 * cos_theta\"]: Normalised curve of the variation of solar transmittance, depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). f_1_minus_rho_nor [[ math-exp-list , default = [\"1.8562 * cos_theta^3 - 4.4739 * cos_theta^2 + 3.6177 * cos_theta\", \"1.8562 * cos_theta^3 - 4.4739 * cos_theta^2 + 3.6177 * cos_theta\"]]: Normalised curve of the variation for (1 - solar reflectance), depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). To obtain the solar transmittance at an angle of incidence theta, the component shall multiply the value at normal incidence solar_tau by the value of the curve f_tau_nor . The following pictures show the solar transmittance of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. To obtain the angular reflectance for each side, multiply the normal incidence value solar_rho by the value of the expression: (1 - f_1_minus_rho_nor ). We use the normalisation of (1 - reflectance) since the reflectance tends to 1 when the angle of incidence tends to 90\u00ba and the value we use to normalise is the reflectance at normal incidence (0\u00ba). The following pictures show the solar reflectance and (1- solar reflectance) of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. Example: ... glazing = pro.new_component(\"Glazing\",\"Double_glazing\") param = { \"solar_tau\": 0.731, \"solar_rho\": [0.133,0.133], \"g\": [0.776, 0.776], \"U\": 2.914, \"f_tau_nor\": \"-0.3516 * cos_theta^3 - 0.6031 * cos_theta^2 +1.9424 * cos_theta\", \"f_1_minus_rho_nor: [\"0.9220 * cos_theta^3 - 2.8551 * cos_theta^2 + 2.9327 * cos_theta\", \"0.9220 * cos_theta^3 - 2.8551 * cos_theta^2 + 2.9327 * cos_theta\"] } glazing.set_parameters(param) Frame Component to describe the thermal properties of frames used in Opening_types. Parameters solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. thermal_resistance [ float , unit = \"m\u00b2K/W\", default = 0.2, min = 0]: Average surface-to-surface thermal resistance of the frame. Example: ... frame = pro.new_component(\"Frame\",\"metal_frame\") param = { \"solar_alpha\": [0.6, 0.6], \"thermal_resistance\": 0.35 } frame.set_parameters(param) Opening_type Component for defining the composition of fa\u00e7ade openings in buildings. For example windows or doors. Parameters glazing [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Glazing\" component used. frame [ component , default = \"not_defined\", component type = Frame]: Reference to the \"Frame\" component used. construction [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Construction\" component used. If the opaque part of an opening is defined by a constraction, it will always be assumed to be in steady state for thermal calculations. glazing_fraction [ float , unit = \"frac\", default = 0.9, min = 0, max = 1]: Fraction of the opening made up of a glazing. frame_fraction [ float , unit = \"frac\", default = 0.1, min = 0, max = 1]: Fraction of the opening made up of a frame. if the glazing_fraction plus the frame_fraction is less than 1 the rest of the area is assumed to be opaque and formed by the defined cosntruction. Example: ... double_glazed_window = pro.new_component(\"Opening_type\",\"double_glazed_window\") param = { \"glazing\": \"double_glazing\", \"frame\": \"wood_frame\", \"glazing_fraction\": 0.8, \"frame_fraction\": 0.2 } double_glazed_window.set_parameters(param)","title":"Component list constructions"},{"location":"component_list_constructions/#component-list-for-constructive-elements","text":"","title":"Component List for constructive elements"},{"location":"component_list_constructions/#material","text":"Component to describe the thermal characteristics of the materials used in the enclosures (Construction component).","title":"Material"},{"location":"component_list_constructions/#parameters","text":"conductivity [ float , unit = \"W/(n\u00b7K)\", default = 1, min = 0]: Material thermal conductivity. density [ float , unit = \"kg/m\u00b3\", default = 1000, min = 0.001]: Material Density. specific_heat [ float , unit = \"J/(kg\u00b7K)\", default = 1000, min = 0.001]: Material specific heat. use_resistance [ boolean , default = False]: If the value is \"False\", conductivity, density and specific heat will be used. For \"True\" value, thermal resistance, density and specific heat will be used. thermal_resistance [ float , unit = \"(m\u00b2\u00b7K)/W\", default = 1, min = 0]: Thermal resistance of material layer. Example: ... material = pro.new_component(\"Material\",\"concrete\") param = { \"conductivity\": 1.95, \"density\": 2240, \"specific_heat\": 900, } material.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#construction","text":"Component to describe the composition of the different layers (Material component) of an enclosure.","title":"Construction"},{"location":"component_list_constructions/#parameters_1","text":"solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity for surfaces 1 and 2. materials [[ component-list , default = [], component type = Material]]: Materials list for each of the layers, defined from surface 1 to 2. thicknesses [ float-list , unit = \"m\", default = [], min = 0]: Thicknesses of each of the layers defined in the \"materials\" parameter. Must have the same number of elements as the \"materials\" parameter. Example: ... construction = pro.new_component(\"Construction\",\"Multilayer wall\") param = { \"solar_alpha\": [0.8, 0.8], \"materials\": [\"Gypsum board\",\"EPS board\",\"Heavyweight concrete\",\"EPS board\",\"Stucco\"], \"thicknesses\": [0.016, 0.076, 0.203, 0.076, 0.025], } construction.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#glazing","text":"Component to describe the glazings. Default values are those of a clear single pane of 6 mm thickness.","title":"Glazing"},{"location":"component_list_constructions/#parameters_2","text":"solar_tau [ float , unit = \"frac\", default = 0.849, min = 0, max = 1]: Solar transmittance of glass at normal incidence. solar_rho [ float-list , unit = \"frac\", default = [0.077,0.077], min = 0, max = 1]: Solar reflectance of glass at normal incidence, for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.837,0.837], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. g [ float-list , unit = \"frac\", default = [0.867093,0.867093], min = 0, max = 1]: Solar factor at normal incidence, calculated according to EN 410:2011, for surfaces 1 and 2. U [ float , unit = \"W/m\u00b2K\", default = 5.686, min = 0]: Thermal transmittance of glazing calculated according to EN 673:2011. f_tau_nor [[ math-exp , default = \"1.3186 * cos_theta^3 - 3.5251 * cos_theta^2 + 3.2065 * cos_theta\"]: Normalised curve of the variation of solar transmittance, depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). f_1_minus_rho_nor [[ math-exp-list , default = [\"1.8562 * cos_theta^3 - 4.4739 * cos_theta^2 + 3.6177 * cos_theta\", \"1.8562 * cos_theta^3 - 4.4739 * cos_theta^2 + 3.6177 * cos_theta\"]]: Normalised curve of the variation for (1 - solar reflectance), depending on the cosine of the angle of incidence, cos_theta (0\u00ba, at normal incidence). To obtain the solar transmittance at an angle of incidence theta, the component shall multiply the value at normal incidence solar_tau by the value of the curve f_tau_nor . The following pictures show the solar transmittance of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. To obtain the angular reflectance for each side, multiply the normal incidence value solar_rho by the value of the expression: (1 - f_1_minus_rho_nor ). We use the normalisation of (1 - reflectance) since the reflectance tends to 1 when the angle of incidence tends to 90\u00ba and the value we use to normalise is the reflectance at normal incidence (0\u00ba). The following pictures show the solar reflectance and (1- solar reflectance) of a single glazing as a function of the angle of incidence, and the normalised curve as a function of the cosine of the angle of incidence. Example: ... glazing = pro.new_component(\"Glazing\",\"Double_glazing\") param = { \"solar_tau\": 0.731, \"solar_rho\": [0.133,0.133], \"g\": [0.776, 0.776], \"U\": 2.914, \"f_tau_nor\": \"-0.3516 * cos_theta^3 - 0.6031 * cos_theta^2 +1.9424 * cos_theta\", \"f_1_minus_rho_nor: [\"0.9220 * cos_theta^3 - 2.8551 * cos_theta^2 + 2.9327 * cos_theta\", \"0.9220 * cos_theta^3 - 2.8551 * cos_theta^2 + 2.9327 * cos_theta\"] } glazing.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#frame","text":"Component to describe the thermal properties of frames used in Opening_types.","title":"Frame"},{"location":"component_list_constructions/#parameters_3","text":"solar_alpha [ float-list , unit = \"frac\", default = [0.8,0.8], min = 0, max = 1]: Solar absortance for surfaces 1 and 2. lw_epsilon [ float-list , unit = \"frac\", default = [0.9,0.9], min = 0, max = 1]: Long wave emissivity, for surfaces 1 and 2. thermal_resistance [ float , unit = \"m\u00b2K/W\", default = 0.2, min = 0]: Average surface-to-surface thermal resistance of the frame. Example: ... frame = pro.new_component(\"Frame\",\"metal_frame\") param = { \"solar_alpha\": [0.6, 0.6], \"thermal_resistance\": 0.35 } frame.set_parameters(param)","title":"Parameters"},{"location":"component_list_constructions/#opening_type","text":"Component for defining the composition of fa\u00e7ade openings in buildings. For example windows or doors.","title":"Opening_type"},{"location":"component_list_constructions/#parameters_4","text":"glazing [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Glazing\" component used. frame [ component , default = \"not_defined\", component type = Frame]: Reference to the \"Frame\" component used. construction [ component , default = \"not_defined\", component type = Glazing]: Reference to the \"Construction\" component used. If the opaque part of an opening is defined by a constraction, it will always be assumed to be in steady state for thermal calculations. glazing_fraction [ float , unit = \"frac\", default = 0.9, min = 0, max = 1]: Fraction of the opening made up of a glazing. frame_fraction [ float , unit = \"frac\", default = 0.1, min = 0, max = 1]: Fraction of the opening made up of a frame. if the glazing_fraction plus the frame_fraction is less than 1 the rest of the area is assumed to be opaque and formed by the defined cosntruction. Example: ... double_glazed_window = pro.new_component(\"Opening_type\",\"double_glazed_window\") param = { \"glazing\": \"double_glazing\", \"frame\": \"wood_frame\", \"glazing_fraction\": 0.8, \"frame_fraction\": 0.2 } double_glazed_window.set_parameters(param)","title":"Parameters"},{"location":"component_list_files/","text":"Component List for reading files File_met component used to read and manage weather files. Creating the necessary weather variables to be used by other components. Parameters file_type [ option , default = \"MET\", options = [\"MET\",\"TMY3\",\"TMY2\"]]: Weather file type. \"MET\": MET format. .MET format (CTE documentation) , \"TMY3\" TMY3 format TMY3 format description , \"TMY2\" TMY2 format TMY2 format description file_name [ string , default = \"name.met\"]: Name of the weather file containing the data. tilted_diffuse_model [ option , default = \"PEREZ\", options = [\"PEREZ\",\"REINDL\",\"HAY-DAVIES\", \"ISOTROPIC\"]]: Model used for the calculation of diffuse solar radiation on inclined surfaces. The simplest model is the isotropic model (\u201cISOTROPIC\u201d) which only takes into account uniform diffuse radiation. The Hay-Davies model includes the influence of the circumsolar component and the Reindl and Perez model also includes the effect of the horizon brightening component. More information about diffuse models on tilted surface Example: ... met = pro.new_component(\"File_met\",\"met\") met.parameter(\"file_name\").value = \"examples/met_files/sevilla.met\" To generate the variables in the simulation time step, the values are obtained by linear interpolation of the data available in the meteorological file. The variables associated with the solar position are calculated, not obtained from the values stored in the file. Variables temperature [\u00b0C]: Dry bulb temperature. sky_temperature [\u00b0C]: Sky temperature, for radiant heat exchange (read from MET files, calculated in TMY3 files). underground_temperature [\u00b0C]: Ground temperature, to be used as the temperature imposed on the outer surface of the enclosures in contact with the ground (currently not read from the file, it is calculated as the annual average air temperature). abs_humidity [g/kg]: Air absolute humidity (calculated). rel_humidity [%]: Air relative humidity. dew_point_temp [\u00b0C]: Dew point air temperature (calculated). wet_bulb_temp [\u00b0C]: Wet bulb air temperature (calculated). sol_hour [h]: Solar hour of the day (calculated). sol_direct [W/m\u00b2]: Direct solar irradiance over horizontal surface. sol_diffuse [W/m\u00b2]: Diffuse solar irradiance over horizontal surface. sol_azimuth [\u00b0]: Solar azimuth (degrees from south: E-, W+) (calculated). sol_altitude [\u00b0]: Solar altitude (degrees) (calculated). wind_speed [m/s]: Wind speed. wind_direction [\u00b0]: Wind direction (degrees from north: E+, W-). pressure [Pa]: Ambient absolute pressure (read from TMY3 files, calculated using standard atmosphere for MET files). total_cloud_cover [%]: Percentage of the sky covered by all the visible clouds (read from TMY3 files, 0 for MET files). opaque_cloud_cover [%]: Percentage of the sky covered, used for infrared radiation an sky temperature estimation (read from TMY3 files, 0 for MET files). File_data Component to read temporary data files and use them as simulation variables. Parameters file_name [ string , default = \"data.csv\"]: Name of the file containing the data. file_type [ option , default = \"CSV\", options = [\"CSV\",\"EXCEL\"]]: Data file type. \"CSV\", file with the values separated by comma. It must contain a first row with the variable names and from the second row the values for each time step. \"EXCEL\": excel file with a single sheet and the same format as described for CSV files. file_step [ option , default = \"SIMULATION\", options = [\"SIMULATION\",\"OWN\"]]: Time step of the data file. The \"SIMULATION\" option assumes that each of the rows in the data file correspond to the time steps of the project simulation. The \"OWN\" option will be used when the time step of the data stored in the data file is different from the one used in the simulation. The parameters \"initial_time\" and \"time_step\" define the time step of the data in the file. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial time of the data file with format \"DD/MM/YYYY hh:mm:ss\". Only used for the \"OWN\" option of the \"file_step\" parameter. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds for the data file. Only used for the \"OWN\" option of the \"file_step\" parameter. If we use the \"SIMULATION\" option of the \"file_step\" parameter and the number of data in the file is less than the number of time steps during the simulation, to obtain the variables we will go back to the beginning of the data file each time the end of the file is reached. the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. If we use the \"OWN\" option of the \"file_step\" parameter and the simulated time instant is before or after the time instants collected in the file, the first value will be taken if it is before and the last one if it is after. Otherwise a linear interpolation will be performed to obtain the values of each of the simulation steps. Example: ... datas = osm.new_component(\"File_dat\",\"datas\") param = { \"file_name\": \"examples/input_files/data_example.csv\", \"file_type\": \"CSV\", \"file_step\": \"SIMULATION\", } datas.set_parameters(param) Variables The component will generate a variable for each of the columns of the data file, using as name and unit for the variable the first row of the file. The unit must be written after the name in square brackets. For example for the following CSV file: n, temperature [\u00baC], humidity [kg/kg as] 1, 15.1, 0.00792 2, 14.6, 0.00788 3, 14.1, 0.00783 4, 13.5, 0.00772 5, 13.0, 0.00766 ... Three variables will be created with names: n, temperature and humidity. And with the units indicated in square brackets.","title":"Component list files"},{"location":"component_list_files/#component-list-for-reading-files","text":"","title":"Component List for reading files"},{"location":"component_list_files/#file_met","text":"component used to read and manage weather files. Creating the necessary weather variables to be used by other components.","title":"File_met"},{"location":"component_list_files/#parameters","text":"file_type [ option , default = \"MET\", options = [\"MET\",\"TMY3\",\"TMY2\"]]: Weather file type. \"MET\": MET format. .MET format (CTE documentation) , \"TMY3\" TMY3 format TMY3 format description , \"TMY2\" TMY2 format TMY2 format description file_name [ string , default = \"name.met\"]: Name of the weather file containing the data. tilted_diffuse_model [ option , default = \"PEREZ\", options = [\"PEREZ\",\"REINDL\",\"HAY-DAVIES\", \"ISOTROPIC\"]]: Model used for the calculation of diffuse solar radiation on inclined surfaces. The simplest model is the isotropic model (\u201cISOTROPIC\u201d) which only takes into account uniform diffuse radiation. The Hay-Davies model includes the influence of the circumsolar component and the Reindl and Perez model also includes the effect of the horizon brightening component. More information about diffuse models on tilted surface Example: ... met = pro.new_component(\"File_met\",\"met\") met.parameter(\"file_name\").value = \"examples/met_files/sevilla.met\" To generate the variables in the simulation time step, the values are obtained by linear interpolation of the data available in the meteorological file. The variables associated with the solar position are calculated, not obtained from the values stored in the file.","title":"Parameters"},{"location":"component_list_files/#variables","text":"temperature [\u00b0C]: Dry bulb temperature. sky_temperature [\u00b0C]: Sky temperature, for radiant heat exchange (read from MET files, calculated in TMY3 files). underground_temperature [\u00b0C]: Ground temperature, to be used as the temperature imposed on the outer surface of the enclosures in contact with the ground (currently not read from the file, it is calculated as the annual average air temperature). abs_humidity [g/kg]: Air absolute humidity (calculated). rel_humidity [%]: Air relative humidity. dew_point_temp [\u00b0C]: Dew point air temperature (calculated). wet_bulb_temp [\u00b0C]: Wet bulb air temperature (calculated). sol_hour [h]: Solar hour of the day (calculated). sol_direct [W/m\u00b2]: Direct solar irradiance over horizontal surface. sol_diffuse [W/m\u00b2]: Diffuse solar irradiance over horizontal surface. sol_azimuth [\u00b0]: Solar azimuth (degrees from south: E-, W+) (calculated). sol_altitude [\u00b0]: Solar altitude (degrees) (calculated). wind_speed [m/s]: Wind speed. wind_direction [\u00b0]: Wind direction (degrees from north: E+, W-). pressure [Pa]: Ambient absolute pressure (read from TMY3 files, calculated using standard atmosphere for MET files). total_cloud_cover [%]: Percentage of the sky covered by all the visible clouds (read from TMY3 files, 0 for MET files). opaque_cloud_cover [%]: Percentage of the sky covered, used for infrared radiation an sky temperature estimation (read from TMY3 files, 0 for MET files).","title":"Variables"},{"location":"component_list_files/#file_data","text":"Component to read temporary data files and use them as simulation variables.","title":"File_data"},{"location":"component_list_files/#parameters_1","text":"file_name [ string , default = \"data.csv\"]: Name of the file containing the data. file_type [ option , default = \"CSV\", options = [\"CSV\",\"EXCEL\"]]: Data file type. \"CSV\", file with the values separated by comma. It must contain a first row with the variable names and from the second row the values for each time step. \"EXCEL\": excel file with a single sheet and the same format as described for CSV files. file_step [ option , default = \"SIMULATION\", options = [\"SIMULATION\",\"OWN\"]]: Time step of the data file. The \"SIMULATION\" option assumes that each of the rows in the data file correspond to the time steps of the project simulation. The \"OWN\" option will be used when the time step of the data stored in the data file is different from the one used in the simulation. The parameters \"initial_time\" and \"time_step\" define the time step of the data in the file. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial time of the data file with format \"DD/MM/YYYY hh:mm:ss\". Only used for the \"OWN\" option of the \"file_step\" parameter. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds for the data file. Only used for the \"OWN\" option of the \"file_step\" parameter. If we use the \"SIMULATION\" option of the \"file_step\" parameter and the number of data in the file is less than the number of time steps during the simulation, to obtain the variables we will go back to the beginning of the data file each time the end of the file is reached. the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. If we use the \"OWN\" option of the \"file_step\" parameter and the simulated time instant is before or after the time instants collected in the file, the first value will be taken if it is before and the last one if it is after. Otherwise a linear interpolation will be performed to obtain the values of each of the simulation steps. Example: ... datas = osm.new_component(\"File_dat\",\"datas\") param = { \"file_name\": \"examples/input_files/data_example.csv\", \"file_type\": \"CSV\", \"file_step\": \"SIMULATION\", } datas.set_parameters(param)","title":"Parameters"},{"location":"component_list_files/#variables_1","text":"The component will generate a variable for each of the columns of the data file, using as name and unit for the variable the first row of the file. The unit must be written after the name in square brackets. For example for the following CSV file: n, temperature [\u00baC], humidity [kg/kg as] 1, 15.1, 0.00792 2, 14.6, 0.00788 3, 14.1, 0.00783 4, 13.5, 0.00772 5, 13.0, 0.00766 ... Three variables will be created with names: n, temperature and humidity. And with the units indicated in square brackets.","title":"Variables"},{"location":"component_list_schedules/","text":"Component List to define schedules Day_schedule Component used for simple definition of daily variation of a value. Parameters time_steps [ int-list , unit = \"s\", default = [3600], min = 1]: time steps where the values change. values [ float-list , default = [0,10]]: Values for the time steps defined in the previous parameter. It must always contain one more element than the parameter \"time_steps\". interpolation [ option , default = \"STEP\", options = [\"STEP\",\"LINEAR\"]]: Procedure used to obtain the values at each of the simulation instants. \"STEP\": The value changes in the form of a step. \"LINEAR\": The value changes linearly between the values defined in the schedule. Example: ... day = pro.new_component(\"Day_schedule\",\"day\") param = { \"time_steps\": [7200,3600], \"values\": [10,20,15], \"interpolation\": \"STEP\" } day.set_parameters(param) The first three hours of the day (7200 s) the value is 10, the next hour (3600 s) 20, and from that instant to the end of the day 15. Using \"interpolation\": \"LINEAR\" this would be the result Week_schedule Component used for simple definition of week variation of a value. It uses to Day_schedule components Parameters days-schedules [ component-list , default = [\"not_defined\"], component type = Day_schedule]: Day_schedule used for the different days of the week. It can contain one value (it will be the one used for all days) or seven values, the Day_schedules for Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday. Example: ... week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) The Day_schedule called \"working_day\" will be used from Monday to Friday, \"holiday_day\" will be used on Saturday an Sunday. Year_schedule Component used for simple definition of year variation of a value. It uses to Week_schedule components Parameters periods [ string-list , default = [\"01/06\"]]: Ends of the different periods. Each of them must be in \"dd:mm\" format. The begining of the first period is \"01/01\" and the end of the last period \"31/12\" weeks_schedules [ component-list , default = [\"not_defined\",\"not_defined]]: Week_schedule to be used in the different periods. It must always contain one more element than the parameter \"periods\". Example: ... year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [\"31/07\",\"31/08\"], \"weeks_schedules\": [\"working_week\",\"holiday_week\",\"working_week\"] } year.set_parameters(param) The Week_schedule called \"holiday_week\" will be used for August and \"working_week\" for the rest of the year. Variables values : values obtained using year, weeks and days schedules for each of the simulation time steps. If the project to be simulated has the daylight_saving parameter activated, summer time will be taken into account when obtaining the hourly values by shifting the values by one hour during the daylight saving period.","title":"Component list schedules"},{"location":"component_list_schedules/#component-list-to-define-schedules","text":"","title":"Component List to define schedules"},{"location":"component_list_schedules/#day_schedule","text":"Component used for simple definition of daily variation of a value.","title":"Day_schedule"},{"location":"component_list_schedules/#parameters","text":"time_steps [ int-list , unit = \"s\", default = [3600], min = 1]: time steps where the values change. values [ float-list , default = [0,10]]: Values for the time steps defined in the previous parameter. It must always contain one more element than the parameter \"time_steps\". interpolation [ option , default = \"STEP\", options = [\"STEP\",\"LINEAR\"]]: Procedure used to obtain the values at each of the simulation instants. \"STEP\": The value changes in the form of a step. \"LINEAR\": The value changes linearly between the values defined in the schedule. Example: ... day = pro.new_component(\"Day_schedule\",\"day\") param = { \"time_steps\": [7200,3600], \"values\": [10,20,15], \"interpolation\": \"STEP\" } day.set_parameters(param) The first three hours of the day (7200 s) the value is 10, the next hour (3600 s) 20, and from that instant to the end of the day 15. Using \"interpolation\": \"LINEAR\" this would be the result","title":"Parameters"},{"location":"component_list_schedules/#week_schedule","text":"Component used for simple definition of week variation of a value. It uses to Day_schedule components","title":"Week_schedule"},{"location":"component_list_schedules/#parameters_1","text":"days-schedules [ component-list , default = [\"not_defined\"], component type = Day_schedule]: Day_schedule used for the different days of the week. It can contain one value (it will be the one used for all days) or seven values, the Day_schedules for Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday. Example: ... week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) The Day_schedule called \"working_day\" will be used from Monday to Friday, \"holiday_day\" will be used on Saturday an Sunday.","title":"Parameters"},{"location":"component_list_schedules/#year_schedule","text":"Component used for simple definition of year variation of a value. It uses to Week_schedule components","title":"Year_schedule"},{"location":"component_list_schedules/#parameters_2","text":"periods [ string-list , default = [\"01/06\"]]: Ends of the different periods. Each of them must be in \"dd:mm\" format. The begining of the first period is \"01/01\" and the end of the last period \"31/12\" weeks_schedules [ component-list , default = [\"not_defined\",\"not_defined]]: Week_schedule to be used in the different periods. It must always contain one more element than the parameter \"periods\". Example: ... year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [\"31/07\",\"31/08\"], \"weeks_schedules\": [\"working_week\",\"holiday_week\",\"working_week\"] } year.set_parameters(param) The Week_schedule called \"holiday_week\" will be used for August and \"working_week\" for the rest of the year.","title":"Parameters"},{"location":"component_list_schedules/#variables","text":"values : values obtained using year, weeks and days schedules for each of the simulation time steps. If the project to be simulated has the daylight_saving parameter activated, summer time will be taken into account when obtaining the hourly values by shifting the values by one hour during the daylight saving period.","title":"Variables"},{"location":"component_list_utils/","text":"Component List for various utilities Calculator Component to perform calculations with the variables of other components. Parameters input_variables [ variable_list , default = []]: List of variables from other components used in this component. They can appear in the expressions of the \u201coutput_expressions\u201d parameter. output_variables [ string_list , default = []]: List of output variable names. output_units [ string_list , default = []]: List of output variable units. output_expressions [ math_exp_list , default = []]: List of output variable mathematical expressions. Variables The component will generate a variable for each of the input variables specified in \"input_variables\" and \"output_variables\" using the mathematical expressions for the calculation in each time step. Example: ... calc = osm.new_component(\"Calculator\",\"unit_change\") param = { \"input_variables\": [\"T = met.temperature\", \"w = met.abs_humidity\"], \"output_variables\": [\"T_F\",\"W_kg\"], \"output_units\": [\"\u00baF\",\"kg/kg a.s.\"], \"output_expressions\": [\"T * 9/5 + 32\", \"w / 1000\"] } calc.set_parameters(param) Four variables will be created with names: T, w, T_F and W_kg, two from input_variables and two from output_variables.","title":"Component list utils"},{"location":"component_list_utils/#component-list-for-various-utilities","text":"","title":"Component List for various utilities"},{"location":"component_list_utils/#calculator","text":"Component to perform calculations with the variables of other components.","title":"Calculator"},{"location":"component_list_utils/#parameters","text":"input_variables [ variable_list , default = []]: List of variables from other components used in this component. They can appear in the expressions of the \u201coutput_expressions\u201d parameter. output_variables [ string_list , default = []]: List of output variable names. output_units [ string_list , default = []]: List of output variable units. output_expressions [ math_exp_list , default = []]: List of output variable mathematical expressions.","title":"Parameters"},{"location":"component_list_utils/#variables","text":"The component will generate a variable for each of the input variables specified in \"input_variables\" and \"output_variables\" using the mathematical expressions for the calculation in each time step. Example: ... calc = osm.new_component(\"Calculator\",\"unit_change\") param = { \"input_variables\": [\"T = met.temperature\", \"w = met.abs_humidity\"], \"output_variables\": [\"T_F\",\"W_kg\"], \"output_units\": [\"\u00baF\",\"kg/kg a.s.\"], \"output_expressions\": [\"T * 9/5 + 32\", \"w / 1000\"] } calc.set_parameters(param) Four variables will be created with names: T, w, T_F and W_kg, two from input_variables and two from output_variables.","title":"Variables"},{"location":"developer_guide/","text":"Developer Guide Under development ...","title":"Developer guide"},{"location":"developer_guide/#developer-guide","text":"Under development ...","title":"Developer Guide"},{"location":"getting_started/","text":"Getting Started The best environment to start using OpenSimula is with Jupyter notebooks or Google Colab . We recommend the use of JupyterLab Desktop Installing OpenSiumula To install OpenSimula you can use any of the methods that Python makes possible. For example, to install using pip we must use: pip install OpenSimula OpenSimula uses in different parts of the code the following Python packages, which will be installed automatically when OpenSimula is installed: NumPy pandas SciPy py-expression-eval shapely psychrolib pyvista[jupyter] plotly dash dash_bootstrap_components dash_ag_grid triangle First example First we are going to define a Python dictionary that contains the information of our project: project_dic = { \"name\": \"First example project\", \"time_step\": 3600, \"n_time_steps\": 24*365, \"initial_time\": \"01/01/2001 00:00:00\", \"components\": [ { \"type\": \"Day_schedule\", \"name\": \"working_day\", \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0], \"interpolation\": \"STEP\", }, { \"type\": \"Day_schedule\", \"name\": \"holiday_day\", \"time_steps\": [], \"values\": [0], \"interpolation\": \"STEP\", }, { \"type\": \"Week_schedule\", \"name\": \"working_week\", \"days_schedules\": [ \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"holiday_day\", \"holiday_day\", ], }, { \"type\": \"Week_schedule\", \"name\": \"holiday_week\", \"days_schedules\": [\"holiday_day\"], }, { \"type\": \"Year_schedule\", \"name\": \"year\", \"periods\": [\"01/08\", \"01/09\"], \"weeks_schedules\": [\"working_week\", \"holiday_week\", \"working_week\"], }, ], } All OpenSimula projects must contain the project definition parameters and a key called components with the list of project components. The project parameters in this example are: name : project name. time_step : Time step used for simulation in seconds. n_time_step : Number of simulated time steps. initial_time : Initial time for the simulation. The project contains two components of type Day_schedule , two of type Week_schedule and one of type Year_schedule . The first Day_schedule component called working_day describes how a value changes throughout the day. The day is divided into five periods described in the time_steps parameter: 8*3600 s (00:00 to 8:00). 5*3600 s (8:00 to 13:00) 2*3600 s (13:00 to 15:00) 4*3600 s (15:00 to 19:00) Rest of day (19:00 to 24:00) The values for these periods are defined in the values parameter, in our example they are 0, 100, 0, 0, 80 and 0. the STEP value of the interpolation parameter sets the value to change in steps from 0 to 100 at 8:00. The other option for the interpolation parameter is LINEAR which would perform a linear interpolation to obtain the values at each simulation instant. The other Day_schedule component called holiday_day sets a single all-day period with value 0. The Week_schedule components define two different types of weeks, the working_week in which a Day_schedule reference is set through the days_schedules parameter setting working_day for Monday through Friday and holiday_day for Saturday and Sunday. The holiday_week component sets a single Day_schedule reference to be used for all days of the week equal to holiday_day . Finally, the Year_schedule named year sets three annual periods using the periods parameter and their respective references to Week_schedule using weeks_schedules parameter which are: January 1st to August 1st: working_week . August 1st to September 1st: holiday_week . September 1st to December 31st: working_week . To simulate this project that we have defined, we first import the OpenSimula.Simulation object to create a simulation environment in the sim variable, a project within that simulation environment called pro . We load the project reading the dictionary that we have explained previously with the read_dict function available for projects and we simulate it using the simulate() function. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"pro\") pro.read_dict(project_dic) pro.simulate() We will get the following in response to these commands: Reading project data from dictonary Reading completed. Checking project: First example project ok Simulation: 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% End After the simulation, each of the components will have its time variables calculated. In our case the year component has a temporary variable called values that we can obtain. the Simulation.plot function can be used to draw an interactive graph (plotly library), the first argument are the dates of the simulation steps (pro.dates() return the array of simulated dates) and the second a list of the varibles to draw. variables = [pro.component(\"year\").variable(\"values\")] sim.plot(pro.dates(), variables) We obtain an interactive graph with the 8760 values on which we can zoom in to show, as an example, the first week of the year.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"The best environment to start using OpenSimula is with Jupyter notebooks or Google Colab . We recommend the use of JupyterLab Desktop","title":"Getting Started"},{"location":"getting_started/#installing-opensiumula","text":"To install OpenSimula you can use any of the methods that Python makes possible. For example, to install using pip we must use: pip install OpenSimula OpenSimula uses in different parts of the code the following Python packages, which will be installed automatically when OpenSimula is installed: NumPy pandas SciPy py-expression-eval shapely psychrolib pyvista[jupyter] plotly dash dash_bootstrap_components dash_ag_grid triangle","title":"Installing OpenSiumula"},{"location":"getting_started/#first-example","text":"First we are going to define a Python dictionary that contains the information of our project: project_dic = { \"name\": \"First example project\", \"time_step\": 3600, \"n_time_steps\": 24*365, \"initial_time\": \"01/01/2001 00:00:00\", \"components\": [ { \"type\": \"Day_schedule\", \"name\": \"working_day\", \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0], \"interpolation\": \"STEP\", }, { \"type\": \"Day_schedule\", \"name\": \"holiday_day\", \"time_steps\": [], \"values\": [0], \"interpolation\": \"STEP\", }, { \"type\": \"Week_schedule\", \"name\": \"working_week\", \"days_schedules\": [ \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"working_day\", \"holiday_day\", \"holiday_day\", ], }, { \"type\": \"Week_schedule\", \"name\": \"holiday_week\", \"days_schedules\": [\"holiday_day\"], }, { \"type\": \"Year_schedule\", \"name\": \"year\", \"periods\": [\"01/08\", \"01/09\"], \"weeks_schedules\": [\"working_week\", \"holiday_week\", \"working_week\"], }, ], } All OpenSimula projects must contain the project definition parameters and a key called components with the list of project components. The project parameters in this example are: name : project name. time_step : Time step used for simulation in seconds. n_time_step : Number of simulated time steps. initial_time : Initial time for the simulation. The project contains two components of type Day_schedule , two of type Week_schedule and one of type Year_schedule . The first Day_schedule component called working_day describes how a value changes throughout the day. The day is divided into five periods described in the time_steps parameter: 8*3600 s (00:00 to 8:00). 5*3600 s (8:00 to 13:00) 2*3600 s (13:00 to 15:00) 4*3600 s (15:00 to 19:00) Rest of day (19:00 to 24:00) The values for these periods are defined in the values parameter, in our example they are 0, 100, 0, 0, 80 and 0. the STEP value of the interpolation parameter sets the value to change in steps from 0 to 100 at 8:00. The other option for the interpolation parameter is LINEAR which would perform a linear interpolation to obtain the values at each simulation instant. The other Day_schedule component called holiday_day sets a single all-day period with value 0. The Week_schedule components define two different types of weeks, the working_week in which a Day_schedule reference is set through the days_schedules parameter setting working_day for Monday through Friday and holiday_day for Saturday and Sunday. The holiday_week component sets a single Day_schedule reference to be used for all days of the week equal to holiday_day . Finally, the Year_schedule named year sets three annual periods using the periods parameter and their respective references to Week_schedule using weeks_schedules parameter which are: January 1st to August 1st: working_week . August 1st to September 1st: holiday_week . September 1st to December 31st: working_week . To simulate this project that we have defined, we first import the OpenSimula.Simulation object to create a simulation environment in the sim variable, a project within that simulation environment called pro . We load the project reading the dictionary that we have explained previously with the read_dict function available for projects and we simulate it using the simulate() function. import OpenSimula.Simulation as Simulation sim = Simulation() pro = sim.new_project(\"pro\") pro.read_dict(project_dic) pro.simulate() We will get the following in response to these commands: Reading project data from dictonary Reading completed. Checking project: First example project ok Simulation: 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% End After the simulation, each of the components will have its time variables calculated. In our case the year component has a temporary variable called values that we can obtain. the Simulation.plot function can be used to draw an interactive graph (plotly library), the first argument are the dates of the simulation steps (pro.dates() return the array of simulated dates) and the second a list of the varibles to draw. variables = [pro.component(\"year\").variable(\"values\")] sim.plot(pro.dates(), variables) We obtain an interactive graph with the 8760 values on which we can zoom in to show, as an example, the first week of the year.","title":"First example"},{"location":"user_guide/","text":"User Guide In this guide you will find information on how to use OpenSimula from an environment that can run Python. The best environment to start using OpenSimula is with Jupyter notebooks . Simulation environment Once we have OpenSimula installed, we can import the package that we will usually name with the alias \"osm\". The first step is to create a simulation environment using the Simulation() function. import OpenSimula as osm sim = osm.Simulation() The simulation object will be used to create and manage the different projects. To create a new project in our simulation environment we will use the new_project(name) function. the project name is stored in a parameter of the project that can be changed later. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project 1\") Simulation functions The following is a list of the most useful functions of the Simulation object: new_project(name) : Create a new project in our simulation environment, with name parameter \"name\". del_project(pro) : Deletes the \"pro\" project. project(name) : Returns the project with name parameter \"name\". Returns \"None\" if not found. project_list() : Returns the list of projects in simulation environment. project_dataframe() : Returns pandas DataFrame with all the projects and its parameters as columns. plot(dates,variables,names=[],axis=[],frequency=None,value=\"mean\") : Draw variables graph (using plotly). dates is the array of dates to be used on the x-axis (can be obtained with the dates() function of the projects). Varibles is a list of variables to be plotted, each one in a serie. Names is the list of names for the series (if empty variables names will be used).frequency [ None , \"H\", \"D\", \"M\", \"Y\"] is the frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\") and value [ \"mean\" ,\"max\",\"min\",\"sum\"], if we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each point (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). project_editor() : When used in Jupyter, it generates a form with a table that allows you to create new projects, delete existing ones and edit the parameters of each project, as shown in the following image. Projects Projects contain a set of components defining a case that can be temporarily simulated. Project parameters name [ string ]: Name of the project. description [ string , default = \"Description of the project\"]: Description of the project. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds used for simulation. n_time_steps [ int , default = 8760, min = 1]: Number of time steps to simulate. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial simulation time with format \"DD/MM/YYYY hh:mm:ss\". daylight_saving [ boolean , default = False]: Taking into account daylight saving time in the simulation. If its value is False, the whole simulation is performed in winter time without daylight saving. If True, the daylight saving time change will be taken into account, mainly in the components that define schedules. daylight_saving_start_time [ string , default = \"25/03/2001 02:00:00\"]: daylight saving start time, with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. daylight_saving_end_time [ string , default = \"28/10/2001 02:00:00\"]: daylight saving start time, time with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. n_max_iteration [ int , default = 1000, min = 1]: Maximum number of iterations in each time step. If after this number of iterations the instant has not converged, it is passed to the next time instant. simulation_order [ string-list , default = [ \"Space_type\", \"Exterior_surface\", \"Underground_surface\", \"Interior_surface\", \"Virtual_surface\", \"Shadow_surface\", \"Opening\", \"Space\", \"Building\" ]]: Order used for the types of components in the simulation loops. All components not specified are added at the beginning and those defined in this list are added at the end in the established order. Example of project for the simulation of the first week of june with 15 min time step. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project one\") pro.parameter(\"description\").value = \"Project example\" pro.parameter(\"time_step\").value = 60*15 pro.parameter(\"n_time_steps\").value = 24*4*7 pro.parameter(\"initial_time\").value = \"01/06/2001 00:00:00\" Project and component parameters can be changed one by one, in bulk using a dictionary and the set_parameter(dictonaty) function, or interactively using the project and component editors. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project one\") param = { \"description\": \"Project example\", \"time_step\": 60*15, \"n_time_steps\": 24*4*7, \"initial_time\": \"01/06/2001 00:00:00\" } pro.set_parameters(param) Project functions The following is a list of the most useful functions of the Project object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the project. parameter_dict() : Returns a dictonary with all the parameters of the project. set_parameters(dict) : Change project parameters using python dictonary. new_component(type, name) : Creates a new component of the type specified in the first argument and with the name of the second argument. del_component(comp) : Deletes the \"comp\" component. component(name) : Returns the component with name parameter \"name\". Returns \"None\" if not found. component_list() : Returns the list of components of the project. component_dataframe() : Returns pandas DataFrame with the components of the project. read_dict(dict) : Read python dictonary \"dict\" with the parameters of the project and a list of component to create. See Getting started for definition dictonary example. After reading the dictonary check() function is executed. read_json(file) : Read json file to define the project. Json file must have the format used for dictionaries in the read_dic function. After reading the file check() function is executed. write_dict() : Return python dictonary with the definition of the project. The default values of the parameters are written explicitly. write_json(file) : Write json file that define the project. The written json file is exactly the same as the dictionary generated by the \"write_dict\" function. check() : Returns the list of errors after checking all the components. All the errors returned are also printed. simulate() : Perform the time simulation of the project, calculating all the varibles of the components simulation_dataframe() : Returns pandas DataFrame with information from the latest simulation. For each time step it includes the number of iterations performed and the name of the last component that forced the iteration. dates() : Returns numpy array with the date of each simulation instant, using winter time without daylight saving. component_editor(type) : When used in Jupyter, it generates a form with a table that allows you to create new compenents, delete existing ones and edit the parameters of each component. If the type is specified, a table with only the components of that type will be displayed. If no type is included or type = \u201call\u201d all components will be displayed but only with the common parameters. Following image shows an example of the component editor: the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on. Components Components are objects included in projects that contain parameters and variables. Component list describe the different types of Components in OpenSimula. As an example, we will see how to create three different types of components and how to manage them in our project. this code is a continuation of the definition of the previous project. ... working_day = pro.new_component(\"Day_schedule\",\"working_day\") param = { \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0] } working_day.set_parameters(param) holiday_day = pro.new_component(\"Day_schedule\",\"holiday_day\") param = { \"time_steps\": [], \"values\": [0] } holiday_day.set_parameters(param) week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [], \"weeks_schedules\": [\"week\"] } year.set_parameters(param) To create the components we use project \"new_component\" function. For example, to create a Day_schedule we will use pro.new_component(\"Day_schedule\",\"name\") . Where the first argument is the type of component and the second the name of the component. After creating the components we can modify any of their parameters. After defining a project with its components, changing the parameters one by one or using a dictionary to define it, we can check if there is any error using the check() function and perform the temporary simulation with the simulate() function. ... pro.check() pro.simulate() Python shell output: Checking project: Project one ok Simulating Project one: 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% End The list of parameters of a project can be obtained in pandas DataFrame format using the project functions parameter_dataframe() . For the components we can get parameters and variables dataframes with parameter_dataframe() and variable_dataframe() . To obtain the list of components in a project with the parameters as columns use the function component_dataframe(comp_type=\"all\") . In the \"type\" argument of the function we can indicate the type of components we want to list (for example: \"Day_schedule\"), or indicate \"all\" (this is the default value), which will show all components including only the three parameters common to all components: \"name\", \"type\" and \"description\". With Jupyter notebooks or Google Collab, writing the python variable of a project the parameter and component dataframe will be shown, and writing one component python variable parameter and variable dataframe will be shown. Next example shows the parameter and component dataframes of our project: ... pro Jupyter shell: Parameters Parameters are used to define the characteristics that make up the projects and components. The parameters will be defined as Python dictionary keys (or json format files), that is the format we will use in the examples shown in the documentation. Parameters can be of different types depending on the type of information they contain: Parameter_string: String of characters, e.g.: \"name\": \"Project 1\" . Parameter_boolean: True or False value, e.g.: \"simplified_definition\": False . Parameter_int: Integer value, e.g.: \"time_step\": 3600 . Parameter_float: Floating point value, e.g.: \"conducticity\": 1.8 . Parameter_options: character string included in a closed option list, e.g.: \"file_type\": \"EXCEL\" . Parameter_component: Reference to another component, e.g.: \"meteo_file\": \"Sevilla\" . Parameter_variable: This parameter is used to create a variable in the component by copying it from another component. A new name is defined and the unit will be taken from the original variable. e.g.: \"input_variables\": \"t_1 = meteo.temperature\" , a variable called \"t_1\" will be created which is a copy of the variable \"temperature\" of the component \"meteo\". Parameter_math_exp: parameter defining a mathematical expression. Each of the components knows how to use that mathematical expression within its simulation process. e.g.: \"people_density\": \"0.1 * f\" , this parameter states that the people density shall be calculated by multiplying by 0.1 a variable called \"f\" that the component must include. All of the above types can also be defined as parameter lists, giving rise to the following types: Parameter_string_list: List of String of characters, e.g.: \"authors\": [\"Juan F.\", \"Luis\", \"Ismael\"] . Parameter_boolean_list: List of True or False values, e.g.: \"operated\": [True, True, False] . Parameter_int_list: List of integer values, e.g.: \"people\": [24, 12, 18] . Parameter_float_list: List of floating point values, e.g.: \"solar_alpha\": [0.8, 0.75] . Parameter_options_list: List of character strings included in a closed option list, e.g.: \"day_types\": [\"MONDAY\", \"TUESDAY\"] . Parameter_component_list: List of references to another components, e.g.: \"materials\": [\"Cement mortar\", \"Hollow brick\"] . Parameter_variable_list: List of parameters used to copy a list of variables. e.g.: \"input_variables\": [\"t_1 = meteo.temperature\",\"hr = meteo.relative_humidity\"] . Parameter_math_exp_list: List of mathematical expressions. e.g.: \"curves\": [\"0.3 * t + 20\",\"0.04 * t^2 - 0.2 * t + 3 \"] . The Parameter_component, Parameter_variable, Parameter_component_list and Parameter_variable_list can refer to a component of the same project, in that case it is only necessary to put the name of the component, or a component of another project. In this last case we must write \"project_name->component_name\". e.g. \"meteo_file\": \"Project 1->Sevilla\" . To get or set the value of a parameter we must use the attribute \"value\" of the parameter. If the parameter contain a list we can set/get each value using index, for example: pro.component(\"week\").parameter(\"days_schedules\").value[0] will return \"working_day\" ... pro.component(\"year\").parameter(\"description\").value = \"Example of year schedule\" pro.component(\"year\").parameter(\"description\").value Jupyter output: 'Example of year schedule' Variables Variables are elements included in the components to store the temporal information generated during the simulation. Variables are lists of floating values, one for each instant of simulated time. To access the values of a variable we use the values attribute which returns a numpy.array object (NumPy library array object). ... pro.component(\"year\").variable(\"values\").values Jupyter output: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ... 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Output is truncated. View as a scrollable element or open in a text editor. Adjust cell output settings... The variable_dataframe(units, frequency, value, interval) method of the components returns a pandas dataframe with all the variables of the component. with the following possible arguments (In bold the default values): units [ False /True]: Include de units in the name of the variable. frequency [ None , \"H\", \"D\", \"M\", \"Y\"]: Frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\"). value [ \"mean\" ,\"max\",\"min\",\"sum\"]: If we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each row (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). interval [ None ,[start_date, end_date]]: List with the start and end dates of the period to be included in the dataframe, if the value is None all values are included. As an example we can see how to obtain the monthly average values of the variables of a meteorological file (File_met component): ... pro.component(\"met_file\").variable_dataframe(frequency=\"M\",value=\"mean\") Jupyter shell:","title":"User guide"},{"location":"user_guide/#user-guide","text":"In this guide you will find information on how to use OpenSimula from an environment that can run Python. The best environment to start using OpenSimula is with Jupyter notebooks .","title":"User Guide"},{"location":"user_guide/#simulation-environment","text":"Once we have OpenSimula installed, we can import the package that we will usually name with the alias \"osm\". The first step is to create a simulation environment using the Simulation() function. import OpenSimula as osm sim = osm.Simulation() The simulation object will be used to create and manage the different projects. To create a new project in our simulation environment we will use the new_project(name) function. the project name is stored in a parameter of the project that can be changed later. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project 1\")","title":"Simulation environment"},{"location":"user_guide/#simulation-functions","text":"The following is a list of the most useful functions of the Simulation object: new_project(name) : Create a new project in our simulation environment, with name parameter \"name\". del_project(pro) : Deletes the \"pro\" project. project(name) : Returns the project with name parameter \"name\". Returns \"None\" if not found. project_list() : Returns the list of projects in simulation environment. project_dataframe() : Returns pandas DataFrame with all the projects and its parameters as columns. plot(dates,variables,names=[],axis=[],frequency=None,value=\"mean\") : Draw variables graph (using plotly). dates is the array of dates to be used on the x-axis (can be obtained with the dates() function of the projects). Varibles is a list of variables to be plotted, each one in a serie. Names is the list of names for the series (if empty variables names will be used).frequency [ None , \"H\", \"D\", \"M\", \"Y\"] is the frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\") and value [ \"mean\" ,\"max\",\"min\",\"sum\"], if we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each point (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). project_editor() : When used in Jupyter, it generates a form with a table that allows you to create new projects, delete existing ones and edit the parameters of each project, as shown in the following image.","title":"Simulation functions"},{"location":"user_guide/#projects","text":"Projects contain a set of components defining a case that can be temporarily simulated.","title":"Projects"},{"location":"user_guide/#project-parameters","text":"name [ string ]: Name of the project. description [ string , default = \"Description of the project\"]: Description of the project. time_step [ int , unit = \"s\", default = 3600, min = 1]: Time step in seconds used for simulation. n_time_steps [ int , default = 8760, min = 1]: Number of time steps to simulate. initial_time [ string , default = \"01/01/2001 00:00:00\"]: Initial simulation time with format \"DD/MM/YYYY hh:mm:ss\". daylight_saving [ boolean , default = False]: Taking into account daylight saving time in the simulation. If its value is False, the whole simulation is performed in winter time without daylight saving. If True, the daylight saving time change will be taken into account, mainly in the components that define schedules. daylight_saving_start_time [ string , default = \"25/03/2001 02:00:00\"]: daylight saving start time, with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. daylight_saving_end_time [ string , default = \"28/10/2001 02:00:00\"]: daylight saving start time, time with format \"DD/MM/YYYY hh:mm:ss\". It will only be used if the daylight_saving parameter is set to True. n_max_iteration [ int , default = 1000, min = 1]: Maximum number of iterations in each time step. If after this number of iterations the instant has not converged, it is passed to the next time instant. simulation_order [ string-list , default = [ \"Space_type\", \"Exterior_surface\", \"Underground_surface\", \"Interior_surface\", \"Virtual_surface\", \"Shadow_surface\", \"Opening\", \"Space\", \"Building\" ]]: Order used for the types of components in the simulation loops. All components not specified are added at the beginning and those defined in this list are added at the end in the established order. Example of project for the simulation of the first week of june with 15 min time step. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project one\") pro.parameter(\"description\").value = \"Project example\" pro.parameter(\"time_step\").value = 60*15 pro.parameter(\"n_time_steps\").value = 24*4*7 pro.parameter(\"initial_time\").value = \"01/06/2001 00:00:00\" Project and component parameters can be changed one by one, in bulk using a dictionary and the set_parameter(dictonaty) function, or interactively using the project and component editors. import OpenSimula as osm sim = osm.Simulation() pro = sim.new_project(\"Project one\") param = { \"description\": \"Project example\", \"time_step\": 60*15, \"n_time_steps\": 24*4*7, \"initial_time\": \"01/06/2001 00:00:00\" } pro.set_parameters(param)","title":"Project parameters"},{"location":"user_guide/#project-functions","text":"The following is a list of the most useful functions of the Project object: parameter(name) : Returns the parameter \"name\". parameter_dataframe() : Returns pandas DataFrame with the parameters of the project. parameter_dict() : Returns a dictonary with all the parameters of the project. set_parameters(dict) : Change project parameters using python dictonary. new_component(type, name) : Creates a new component of the type specified in the first argument and with the name of the second argument. del_component(comp) : Deletes the \"comp\" component. component(name) : Returns the component with name parameter \"name\". Returns \"None\" if not found. component_list() : Returns the list of components of the project. component_dataframe() : Returns pandas DataFrame with the components of the project. read_dict(dict) : Read python dictonary \"dict\" with the parameters of the project and a list of component to create. See Getting started for definition dictonary example. After reading the dictonary check() function is executed. read_json(file) : Read json file to define the project. Json file must have the format used for dictionaries in the read_dic function. After reading the file check() function is executed. write_dict() : Return python dictonary with the definition of the project. The default values of the parameters are written explicitly. write_json(file) : Write json file that define the project. The written json file is exactly the same as the dictionary generated by the \"write_dict\" function. check() : Returns the list of errors after checking all the components. All the errors returned are also printed. simulate() : Perform the time simulation of the project, calculating all the varibles of the components simulation_dataframe() : Returns pandas DataFrame with information from the latest simulation. For each time step it includes the number of iterations performed and the name of the last component that forced the iteration. dates() : Returns numpy array with the date of each simulation instant, using winter time without daylight saving. component_editor(type) : When used in Jupyter, it generates a form with a table that allows you to create new compenents, delete existing ones and edit the parameters of each component. If the type is specified, a table with only the components of that type will be displayed. If no type is included or type = \u201call\u201d all components will be displayed but only with the common parameters. Following image shows an example of the component editor: the first simulation instant is the initial_time plus 1/2 of the time_step. For example, if initial_time = \u201c01/01/2001 00:00:00\u201d and time_step = 3600, then the first simulation instant is: \u201c01/01/2001 00:30:00\u201d, the second: \u201c01/01/2001 01:30:00\u201d, and so on.","title":"Project functions"},{"location":"user_guide/#components","text":"Components are objects included in projects that contain parameters and variables. Component list describe the different types of Components in OpenSimula. As an example, we will see how to create three different types of components and how to manage them in our project. this code is a continuation of the definition of the previous project. ... working_day = pro.new_component(\"Day_schedule\",\"working_day\") param = { \"time_steps\": [8*3600, 5*3600, 2*3600, 4*3600], \"values\": [0, 100, 0, 80, 0] } working_day.set_parameters(param) holiday_day = pro.new_component(\"Day_schedule\",\"holiday_day\") param = { \"time_steps\": [], \"values\": [0] } holiday_day.set_parameters(param) week = pro.new_component(\"Week_schedule\",\"week\") param = { \"days_schedules\": [\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"working_day\",\"holiday_day\",\"holiday_day\"] } week.set_parameters(param) year = pro.new_component(\"Year_schedule\",\"year\") param = { \"periods\": [], \"weeks_schedules\": [\"week\"] } year.set_parameters(param) To create the components we use project \"new_component\" function. For example, to create a Day_schedule we will use pro.new_component(\"Day_schedule\",\"name\") . Where the first argument is the type of component and the second the name of the component. After creating the components we can modify any of their parameters. After defining a project with its components, changing the parameters one by one or using a dictionary to define it, we can check if there is any error using the check() function and perform the temporary simulation with the simulate() function. ... pro.check() pro.simulate() Python shell output: Checking project: Project one ok Simulating Project one: 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% End The list of parameters of a project can be obtained in pandas DataFrame format using the project functions parameter_dataframe() . For the components we can get parameters and variables dataframes with parameter_dataframe() and variable_dataframe() . To obtain the list of components in a project with the parameters as columns use the function component_dataframe(comp_type=\"all\") . In the \"type\" argument of the function we can indicate the type of components we want to list (for example: \"Day_schedule\"), or indicate \"all\" (this is the default value), which will show all components including only the three parameters common to all components: \"name\", \"type\" and \"description\". With Jupyter notebooks or Google Collab, writing the python variable of a project the parameter and component dataframe will be shown, and writing one component python variable parameter and variable dataframe will be shown. Next example shows the parameter and component dataframes of our project: ... pro Jupyter shell:","title":"Components"},{"location":"user_guide/#parameters","text":"Parameters are used to define the characteristics that make up the projects and components. The parameters will be defined as Python dictionary keys (or json format files), that is the format we will use in the examples shown in the documentation. Parameters can be of different types depending on the type of information they contain: Parameter_string: String of characters, e.g.: \"name\": \"Project 1\" . Parameter_boolean: True or False value, e.g.: \"simplified_definition\": False . Parameter_int: Integer value, e.g.: \"time_step\": 3600 . Parameter_float: Floating point value, e.g.: \"conducticity\": 1.8 . Parameter_options: character string included in a closed option list, e.g.: \"file_type\": \"EXCEL\" . Parameter_component: Reference to another component, e.g.: \"meteo_file\": \"Sevilla\" . Parameter_variable: This parameter is used to create a variable in the component by copying it from another component. A new name is defined and the unit will be taken from the original variable. e.g.: \"input_variables\": \"t_1 = meteo.temperature\" , a variable called \"t_1\" will be created which is a copy of the variable \"temperature\" of the component \"meteo\". Parameter_math_exp: parameter defining a mathematical expression. Each of the components knows how to use that mathematical expression within its simulation process. e.g.: \"people_density\": \"0.1 * f\" , this parameter states that the people density shall be calculated by multiplying by 0.1 a variable called \"f\" that the component must include. All of the above types can also be defined as parameter lists, giving rise to the following types: Parameter_string_list: List of String of characters, e.g.: \"authors\": [\"Juan F.\", \"Luis\", \"Ismael\"] . Parameter_boolean_list: List of True or False values, e.g.: \"operated\": [True, True, False] . Parameter_int_list: List of integer values, e.g.: \"people\": [24, 12, 18] . Parameter_float_list: List of floating point values, e.g.: \"solar_alpha\": [0.8, 0.75] . Parameter_options_list: List of character strings included in a closed option list, e.g.: \"day_types\": [\"MONDAY\", \"TUESDAY\"] . Parameter_component_list: List of references to another components, e.g.: \"materials\": [\"Cement mortar\", \"Hollow brick\"] . Parameter_variable_list: List of parameters used to copy a list of variables. e.g.: \"input_variables\": [\"t_1 = meteo.temperature\",\"hr = meteo.relative_humidity\"] . Parameter_math_exp_list: List of mathematical expressions. e.g.: \"curves\": [\"0.3 * t + 20\",\"0.04 * t^2 - 0.2 * t + 3 \"] . The Parameter_component, Parameter_variable, Parameter_component_list and Parameter_variable_list can refer to a component of the same project, in that case it is only necessary to put the name of the component, or a component of another project. In this last case we must write \"project_name->component_name\". e.g. \"meteo_file\": \"Project 1->Sevilla\" . To get or set the value of a parameter we must use the attribute \"value\" of the parameter. If the parameter contain a list we can set/get each value using index, for example: pro.component(\"week\").parameter(\"days_schedules\").value[0] will return \"working_day\" ... pro.component(\"year\").parameter(\"description\").value = \"Example of year schedule\" pro.component(\"year\").parameter(\"description\").value Jupyter output: 'Example of year schedule'","title":"Parameters"},{"location":"user_guide/#variables","text":"Variables are elements included in the components to store the temporal information generated during the simulation. Variables are lists of floating values, one for each instant of simulated time. To access the values of a variable we use the values attribute which returns a numpy.array object (NumPy library array object). ... pro.component(\"year\").variable(\"values\").values Jupyter output: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., ... 100., 0., 0., 0., 0., 0., 0., 0., 0., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 80., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Output is truncated. View as a scrollable element or open in a text editor. Adjust cell output settings... The variable_dataframe(units, frequency, value, interval) method of the components returns a pandas dataframe with all the variables of the component. with the following possible arguments (In bold the default values): units [ False /True]: Include de units in the name of the variable. frequency [ None , \"H\", \"D\", \"M\", \"Y\"]: Frequency of the data, that of the simulation (None), hourly (\"H\"), daily (\"D\"), monthly (\"M\") or yearly (\"Y\"). value [ \"mean\" ,\"max\",\"min\",\"sum\"]: If we use a frequency other than the simulation frequency (e.g. monthly \"M\"), the value obtained for each row (month) will be the mean (\"mean\"), the maximum (\"max\"), the minimum (\"min\") or the sum (\"sum\"). interval [ None ,[start_date, end_date]]: List with the start and end dates of the period to be included in the dataframe, if the value is None all values are included. As an example we can see how to obtain the monthly average values of the variables of a meteorological file (File_met component): ... pro.component(\"met_file\").variable_dataframe(frequency=\"M\",value=\"mean\") Jupyter shell:","title":"Variables"}]}